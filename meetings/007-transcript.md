# Meeting 7 Transcript

July 9, 2024

All right. Hello, folks. Welcome to Open Canvas Working Group Meeting number seven.

A couple of, if you're watching this recording, you might be wondering what this is about. We're trying to make an open standard for Canvas or infinite Canvas apps that basically an interoperable format that allows things like TLDraw and Excalidraw and even node and wire programming tools and to all communicate with one another and be able to pass canvases around between those different tools.

You can go find out more on the website at canvasprotocol.org. Let me share this thing to bring that up. There we go. On canvasprotocol.org, you can find a link to past meetings and recordings and such like that, but most of the activity happens in GitHub, GitHub.com/OCWG. There are discussions there. We try to keep most of our stuff in a permanent format like in discussions where people can come and contribute and see what people have been talking about. There is a discord if you're into that kind of thing, so feel free to join up with that.

The main deliverable we're working on right now is a draft spec that you can find in the spec repo under OCWG working towards getting basically a document that describes the first OCWG format. The other deliverables are basically demos of that specification. Michael is going to show a demo today. We had a demo from a couple of folks last week as well. Basically just working on pushing on two fronts of trying to get this spec to a point where we feel like it's good enough to share more broadly, but also doing some implementations of the spec to make sure that we kind of run up against any holes in it. We'll talk about some of those today.

We do not have any introductions today since I know all of you already, so we can move right on to Michael, your demo. Do you want to go first? Yes. Yeah, that's fine. I will share my screen. Let me turn on screen sharing for you. Post tools, enable screen sharing. Okay, there you go. Let's see.

This one should be the... When you see my screen, it should be. I'm developing a visual programming environment in my spare time as a side project. I'm also very much interested in also exporting to the open canvas. What you see here is a small flow that's just a counter. I'll show other flows in a few minutes. On the bottom right, you see the export of the current spec, at least on how I read it.

Also, the full back is implemented. It's just a text of a note. One of the things that I don't have currently yet is importing back. Since this environment is, of course, quite structured, I don't have some concept of a rectangle. Every note has some kind of meaning. I probably need something like that if I want to build, for example, a flow with TLDraw and import that in my application.

You were saying that nodes... How is each node represented? What were the choices you made about?

I currently put the properties of the nodes from this system in the sub-property, and this probably will go and work differently when the spec evolves, like the proposal of Max. I would not advise in putting all this under properties because of naming conflicts between different tools. I can imagine that all the tools have also got something that's called type, or different things, but currently in this tool type is the way it specifies what node is. This is a variable. This is that expression. You also see that expression, that counter plus one, that's written there. Or is that set variable, that's here.

I also have the connections in there, which are the arrow schema in the spec. This is just one connection from one node to another, but I have more complex scenarios. Let's see. Maybe this is a good example because nodes can have different ports, so you need to have specified it somewhere. Let's see if I can find it. It's quite a little bit of a bigger flow, of course. I cannot find it that quickly, but it should be.

It's not that important. This has two start points with a port name. Maybe it's difficult to find it. No worries. You chose to make each one of the nodes in your system a rectangle, or to represent it as a rectangle, or did you just come up with one single schema for it? Yes, this is a triangle, but below the hood it's a rectangle. And the schema you called it, code flow canvas, what was the slash what?

Well, I have different implementations. What were all the schemas that you ended up using? Yes, well, this engine is more or less a webflow engine. This is a simple state machine with which you can control, but I also have more of a graphic language, although I don't want to make this a demo of my tool. No, this is very cool. I think it's really important that we understand the capabilities of the tools and make sure that there's a way of representing as much as we think is reasonable of the capabilities of that tool with the specification. Obviously, we won't have executable OCWG specs, or maybe we will at some point, that you could take a raw OCWG spec and produce some output. But that's not the goal. The goal would be to make sure that, as you, like you said, open this up in TLDraw, that the things come through with some at least conceptual fidelity. And that's so I was curious about the different schemas that you use to represent your different objects in your or nodes in your system.

So it seems like you have these node boxes that can be a variety. They can have a variety of different things, including specifying an expression, a variable, some things like sliders and stuff like that. And you represent all of those as rectangles. Yeah, most of them are. I also have diamonds for conditions. This big gray rectangle is a group container, which you can place all the nodes. So if you move, this is a bug, I think. Sure. And I have arrows, different kinds of arrows. As you look at here, you can see these arrows are connections from one node to another. I think there's a bug here in here still. But if I would move this node, then the arrow would move. These, because these are states and transitions of a state machine, they behave a little bit different than normal, than these kind of nodes, which achieve inputs and have an output. There's behavior behind each node. I also have a registry in which I can add all the node types. Interesting. Let's see where I was. I also have nodes where I can store multiple images, media files. And is that, am I looking at a group right there, the media files? Is that a group that's the gray thing? And then there's a button that's a separate object called an ad that you would, for adding? No, this is just a regular node type without outputs. But I've defined a form in it with an array, which in which you can, if I would do an ad, I could upload the media via file or give the name. And I can reference that name in the flow. There's no to react to two actions from the state machine. It shows, it's an image, a show image container, and it shows nodes depending, images depending on that media library.

Did you, what did you do with relations in this case? For each of the arrows, did you add a relation mapping as well for each of the arrows? No, I was wondering what I should do with that if that was needed. But I know with TLDraw, that's needed. You have to do a special relation for the arrows. Currently, I have not done that, but it's easy to also export a relation for the connections. The group, yeah, the group. Yeah, yeah, yeah. So what we were thinking about for arrows is we kind of separated the idea of an arrow as a, like you're pointing at something. Like, for example, in TLDraw, or, oh, I guess I have a TLDraw. Well, for those of you who are in the TLDraw, you can just draw an arrow from nothing to nothing. And it doesn't represent, it's not actually a relation in any way. It's more like a graphical object for calling attention to something. An arrow can have no relations at all. Or an arrow can connect two objects, in which case, it has a relation, yeah, exactly. So yeah, just like that. So in this case, this is exactly the case. Thank you for drawing this. So in this case, you would have three nodes, but no relations. Right. And so then connecting those two, connecting that arrow to one of those objects should also add a relation. Now, as you mentioned, TLDraw doesn't have at least like base TLDraw. How should I say this? TLDraw doesn't natively take advantage right now of relations in its base feature set. But a lot of the things that people are doing to add functionality on top of TLDraw, they are taking advantage of the fact that there are parent-child relationships in the TLDraw data model. But that's just for TLDraw. If you were exporting to another tool that was primarily a conceptual tool, like X state or something like that, you would want those relations to transfer over. So then TLDraw, you've got the bindings. That's what you need. If you export an arrow, you export the arrow itself, but also a binding. The bindings connect the endpoints to the rectangles or nodes in TLDraw. Right. Yes. TLDraw has the ability to set the points at which you are binding onto that object so that you can very finely customize where the arrow sits. And I would assume that your rectangles have a similar thing of there's a binding on the left and right side of each one of your rectangles. Yeah, ports. I call them ports. Yeah. It's no type

. You have different ports, which kind of different meanings. Exactly. Yeah, I think the interesting piece here is, I believe, and I wish Ryan were here to speak to this, but TLDraw actually also has an idea of parent-child relationships between objects. And that's purely conceptual. It happens to be one to one. It happens to be when there is a parent-child relationship, there is also an arrow in TLDraw, but that is sort of incidental that that is the case. So yeah, that's probably something we should make clear in the spec is... I also had a question, actually. How should the schemas properly be handled? Currently, I just put in the schema of nodes in there and how it should be linked in the spec. So that you know that code for canvas nodes is a rectangle in OCWG. I forgot to add connections here, but they should be here as well. And in the spec, I talked about the JSON schema format, I believe, but I couldn't... I looked at it, but I couldn't... Yeah, it couldn't make sense of it how it was intended. Right. You can imagine that you could put maybe all properties of code for canvas nodes in here, but I don't think you want that. This seems to make sense for me, that if a different tool wants to import an export that this tool made, that you can know how to represent it. So in the semantic web in RAF, you usually link a schema by URL and then cleverly host the URL so that the machine will get back the schema file, the technical file, and the web browser will get a human readable web page. And so you use just one URL to identify it and provide everybody with stuff. But the setup is a little bit tricky. Maybe supplying two URLs, one for download, one for info would also work. Could you give me an example description of that on GitHub? Sort of a point you have URLs described so I can read more about it. Yeah. Not yet understanding what you mean. Yeah, that's definitely something I had on the agenda to discuss today because I saw your GitHub discussion about it as well. So Max, there is already a GitHub question from discussions question from Michael on this on that topic. Definitely, I went back and read through the schema right before this call and made some updates to the schema. I'm sorry, the spec, sorry, not the schema. I read through the whole spec and made some updates to it to align it with previous meetings that we've been discussing. And you're right, we don't fully specify how the schemas should be specified. We also don't specify how to extend the schemas based on one another or like extend from another schema. So the general idea, though, is that the schema, the OCWG file, the OCWG file, when you get a file as someone who's receiving it, you should have everything you need to render that file, meaning that you need the schema for all of the relevant schemas or all of the nodes and relations in that file need to be in the file itself. And so we were thinking about representing that using JSON schema and we can give some examples of how that might look.

So in this schema section that you've got right down here, oh, Ryan, just to catch you up real quick, Michael was giving a demo of Codeflow Canvas exporting to OCWG's format. So right now, and what you're seeing right there is he's got a couple of objects. And as he changes those objects, it updates the iframe in the bottom right with an OCWG format live. So pretty nice. But yeah, so then if we have the, so yeah, we would use JSON schema to represent the schemas and put them in the schema section. And I believe JSON schema has a way of specifying a relationship between schemas where you could say this schema extends this other schema. Go ahead, Max. Yeah. Actually, as we will maybe also talk about assets where files can reside inline, attached to it or on the web, maybe schemas could be in the same way. Yeah, I think that's fine. Yeah, we should probably support the same mechanisms for inline locally and on the web and just have parallelism there between the way that we're handling content for assets, like you mentioned, or yeah, make those use a similar method. We'll be websites of tools need to host the schema information themselves, or will there be a registry with schema information? Yeah, I think that's definitely exactly. That's one of the, I think one of the things that we would encourage people to do at first is just default to inlining all of the schemas. But having the capability of storing schemas externally doesn't seem a bad thing, especially what Max is referring to as something we discussed two weeks ago, of how we would handle potential external assets like images and that kind of stuff. To refer to images directly, or to talk about images specifically, we might want to be able to inline an image using like base64, and it's just right there in the file itself, or refer to a file that's an image that's on the local file system or a local directory that OCWG file is packaged up with, or not just a relative URI, but an absolute URI of a location on the internet where you're trying to get that from.

Let's see. And so why not, I think what Max is saying is why not support that same structure for schemas themselves, which seems reasonable. See someone in the discord trying to get in, I'm going to try and help them get in real quick. What other things came up while you were building this, Michael, that you had questions about? I like that these nodes arrays are arrays, not no longer objects. And I was wondering if this also be actually set order for the nodes, or that there will be an index like property, for example, which TLDraw uses, it has its own algorithm behind it, although it's, I believe, inspired by something else, but that makes, I think, collaboration maybe easier if tools use the same algorithm.

You're talking about, are you mentioning Zindex here? I think the plan is to have Z ordering be its own order should be its own property. This array could be, for the spec at least, could be the order. That is the way that JSON Canvas from Obsidian handles it. They use the array to specify the Zindex Z order. I'm a fan of explicitly specifying it with a property, rather than just in its own array order. You could, by convention, order it by Zindex when exporting it, and that helps with some human interpretability. But having an explicit property seems, I don't know why that seems better to me, I'd have to think it through, but that would be that. Well, if that property is, how do you say it, in TLDraw, it's a special format. You cannot, it's not a number that comes up by one, it's more like a float. So that if you want to put one node behind another node, that you just have to do some calculations and the node is in a different set as at all. In one of the discussions, I put a link to, I think, to the code in TLDraw, if I'm not mistaken. I'll be honest, I don't have strong reasoning or instincts on that one. It just seems better as a property, but I would defer to someone else who has given that more thought on that specific one.

So yeah, we talked about the Zindexy order, I think we have a GitHub discussion on that. I think making it explicit as a property allows for more use cases. Let's say we have a canvas that has like three panes of Zindex, and then you can just write at each item at which pane they are. I mean, you don't need to have a canvas that just orders everything at different Zindexes. It's true, you can have ties, but maybe that's actually the purpose to say that they are on the same depth for whatever reason, I mean, or a spatial tool where you use your HoloLens and view it, and then things need to be at a certain depth that just looks good. Exactly. Just in 2D, we need to stack them all up. So it's maybe 2TL draw specific to say we use the array index. Yeah, I'm going to cautiously say this, I haven't thought this through. Go ahead, Ryan. But maybe the actual Z spatial dimension could be suitable for that, but the reason why I'm thinking that that's a possibility is if you're working at 2D, you don't need it, and it's analogous to Z ordering already. And then in 3D, you don't need Z ordering because you have three dimensions, and so when you're drawing it, that's not how you're calculating the kind of render ordering and inclusion and stuff like that. It's going to be done geometrically based on the its 3D location and its geometry. Yes, you're overloading the two ideas of in a 2D canvas, it will be Zindex in a 3D environment, it will be its Z location, which is perfect. I kind of like it actually. They're just sort by the Z, and then you get an order, and that's what you want. Yeah. And if there are ties, then depending on the use case, somebody should remove the ties first, maybe. Yeah, just to delve into that, make sure you understand it. I like the idea, but in 3D, wouldn't it be a matter also of your camera can shift? So it's not as simple as shifting the Z index because you could go to the side. Anyway, it's intriguing. I love the thought.

Yeah, so in 3D, for a given pixel, what pixel is rendered is going to be a function of the coordinate in 3D space, the position of rotation of the camera, and then the geometry, like if you have a cube or a sphere, the size is going to potentially overlap with other things. Yeah, it's fascinating. Yeah,

 that makes sense. So I guess one thing about this as well is that if you wanted to take something from a 2D canvas and chuck it into a 3D environment, either you leave the Z indexes as they are because they're useful layering and they're going to trip stuff up, or you would reset them. But I guess that would be a user space thing. I don't know if we're planning for lots of round trapping between 2D and 3D, although I don't see why we shouldn't try. Yeah, it's a bit of a rabbit hole, but it does seem interesting that at least in 2D, Z index has, at times, a use as metaphorically similar to onion skinning with animation. It's like there's a history component, and that doesn't translate to 3D as easily, but that's a very interesting topic. I'll put a link to the algorithm that Thiel uses in the chat. It's a fractional indexing. Got you. And I think that's much higher, I'm not sure, but I did read this before in my takeaway. And my takeaway was that it's, that's great for, that's more important for how a tool internally handles ordering, rather than how to specify it in an interrupt format. But yeah, it's been a bit since I read it. Yeah, I do agree, but I think that for tools like Thiel, when you are, like we are currently doing collaborating on one canvas and updating some canvas in real time, that such algorithm does really help. So if maybe if we want to have, if we want tools also to collaborate in real time using the OCWG spec, then maybe we do need something like this, but I'm not sure. That's it. Let's see, I wanted to, we've got about 25 minutes left. Michael, were there other things that came up while you were working on the Codeflow Canvas demo? We've addressed some of them already. We talked about how arrows may optionally need a relation, a relation. And to specify what's an arrow node, it may clear that an arrow node may optionally need a relation in order to indicate the relationship between the two objects. We talked about specifying how to specify schema and schema extensions. We need to clarify that in the spec. I think that's something that Orion and I can take on. Because we did discuss more of this than in the spec. I was just going to say, we discussed, we did discuss more about how this would work than we've actually documented so we can get what we have into the spec documented. Anything else that you ran into that you want to share? Yeah, for my tool itself, importing back. Because in my tool, the nodes have meaning. There's a type link to it, a specific type. So I cannot yet, at least in my tool, import back random shapes which are not linked to any node type in my tool. So that's something that I need to handle, I think, in my tool. Oh, I see, I see. So you almost need to decide when bringing in, when importing from a TL draw that hasn't exported, this is like when going from a canvas that is not your canvas and bringing that into yours, you need to decide what type to assign to rectangles that have no type yet. Have you tried, you could roundtrip in terms of you could save to OCWG and then open in OCWG one of your own files, that works, right? I don't understand, what do you mean? So taking node code flow, code flow canvas, name the tool, right? Yeah, and then outputting an OCWG file. Yeah, that works. And then importing it back in, that works. Yeah, that would work. If I export an input back, I've done that with also with TL draw, actually, but then I simply, I don't import any new nodes, I just sync the nodes that I have in my own tool, right? I think that's a decision that your tool has to make, right? That's not something that OCWG or TL draw can handle for you, which is how do I handle rectangles, how do I represent rectangles that don't yet have an assigned type? Yeah, I agree. But that isn't, I think you're right, I think you're hitting on a larger challenge here, which is that we have to kind of say this properly. Tools, as interrupt between tools increases, there will be cases where a tool has to decide if and how it wants to deal with objects that it doesn't natively know about. Like, should I just ignore those nodes entirely? And make sure that they get written back out to the file? Or should I try to represent them as something in my system? And I'm just going to have to do the thinking about how they should be represented in my tool. So maybe both. You need to do sometimes both, but there are some notice types that you can't really represent in a tool, with all those you can. But at least you have to keep, yeah, you have to be aware of them and write them back. That's a requirement, I think. Yeah, you have to maintain them and write them back out again. But you don't have to exactly. Yeah. And I think I actually did document this in the spec max. There's a big section that says, basically says, this is the hard part about supporting the CWG, is that when you have nodes you don't know, you still have to keep them and write it all back out. You can't just like drop them on the floor just because you don't know what they are. That's a great. Jen is mentioning in the chat that the GLTF extensions ecosystem also uses JSON. That's definitely something that we should go see if we can take a page from. All right. So I think we've made it through the first three items on the agenda. We've discussed schema extensions in terms of we just need to just specify a little bit more. I guess the other piece there that I didn't write down, and I want to make sure I capture is what max drops into chat, which is this. We should maybe handle that the same way. All right. Then Z-order, we can discuss more. I wanted to look at Max's post about asset handling and make sure I understand that. And then, Jen, if you wanted to talk about, if you wanted to share a little bit about the GLTF stuff in a second, feel free to grab some links, and we'll hopefully spend about 10 minutes on this next topic, and then we can talk about GLTF. You can maybe share what's going on there. All right. So discussions.

So this is similar to what Max was just saying about schemas that they should probably be able to be stored locally or in the inline at a local URI and at a remote URI. So this is this content can live inline as a string as a local file parallel to that canvas JSON relative URI, or as an external absolute URI that they could be referenced or look up. I think one of the consequences of this is this proposal is that we don't need a generic OCWG slash asset node anymore. It's basically everything has a type, OCWG image, OCWG text, whatever that could be marked down here, could pull from some text resource out there at that URI piece. And this makes a lot of sense to me, and having a mime type in content makes a ton of sense. So would we then say that, like, any, should all properties have a mime type and content or any time you have content as part of your property, as part of the schema for your this node, use this format, basically have a mime type and have a content URI. I wouldn't over engineer it. So the mental image I had here was rest. So you have the web, you find a URL somewhere, you get it, and you get a representation. And that representation depends on your capabilities. Like you say, I'm a text only browser, I only accept text, what can you give me, and the browser will give you a plain text variant. Or you say, I'm an HTML browser, you get an HTML web page back. That's content negotiation. In order to have that in an offline file, we need an array with multiple content versions. Each states what it is by mime type, and then we find out where to actually grab the content bytes inline thoroughly externally. So then we can render the first thing we understand, or if we have some preference, the first thing matching our preference. So we have an array of content snippets. But this is already a quite heavyweight thing to have an array of different content types and have to select the right one, maybe even the right language, could also be part of the content selection process as defined by the web. And then we have metadata. Like these things have a position and have a color and so on. And they have like, it's what was actually a heavyweight image, and we have an alt text. And this alt text is the string, but I wouldn't go the same route again and say, yeah, actually, this alt text, now you can also fetch. And it also has 17 representations in different lengths. No, that's just one string. And if you really need more complex things, then define it in your property back as you need it. But in general, I would say we have content. That's what makes up the canvas content blocks. They are arranged. And then they are augmented by more metadata so that more tools can do cooler things with them, like what Michael did with codeflow blocks. But they still remain one thing with content in its essence. So, yeah, at least a mental image that helps me to understand what OCWG actually is doing. It's arranging web-like resources on a canvas and defining an export format for that.

That actually is, I think, fairly consistent with the actual implementation of TL draw itself. Perfect. TL draw is implemented. If I remember correctly, they skipped the canvas renderer and rendered everything as actual HTML elements and positioned them using CSS and all

 that kind of stuff and didn't take advantage of HTML's canvas tool. And so one of the consequences of that for TL draw, and I think this makes sense for OCWG as well, is that you can represent any kind of HTML resource on a TL draw canvas without having to re-implement anything. So, for example, like dropping this link here, created this embed. And, yeah, this is, it was fairly trivial to lean on. Now, there's downsides to all of this, obviously, but like some of the implementation trade-offs that I understand. And so, yeah, that kind of, that maps well into my understanding of the way you should build a canvas tool as well. Not that you couldn't use HTML's canvas and all that, but you could, yeah. With the important note there, that we're not assuming that different canvas tools have access to the web, a web-based stack. We're just kind of drawing inspiration for what's been proven to work. Yes, exactly. It's a proven design paradigm. So, in that case, like, these are like minor nitpicky things to make sure I'm understanding it. Would, were you saying that, so I heard you say content as an array of snippets, and obviously we could have other ones like other MIME types here for like rich text or something instead of just plain text, but like this should be text slash plain. And you could have text slash markdown and other things like that. Should we also support like content can be either a string or like array, and then you could have, you could have the ability to like specify content very simply. And if it's a string, the understanding is the MIME type is text plain, and the kind like you don't have to infer anything keeps it like really nice and lightweight. I'm not sure what that creates, what problems that creates for implementers, but it seems like that would be a nice trade-off for simplicity when you wanted it. Why not? I mean, this makes the spec more heckable for human editors, if we, but we then have to burden for every parser to say, okay, if we find this thing, I need to normalize into that. So there could be a pre-processing tool to parse an OCWG file and create the canonical version of it, obviously. Yeah, I mean, yeah, in this case, I guess the thing that we were just describing, right, these two things would be exactly the same thing, content something and content text plain something. And so I don't, this is obviously, like you said, a lot easier for humans to write, and that is the much more robust format. I think it's a good idea. There will probably be many notes that have a simple string, and it doesn't make sense to give them a big burden to just write out that simple string. That's definitely one of the nice things about JSON Canvas. It has some challenges to it, but it feels very simple and is fairly human readable for a JSON file anyway. I think their text type, they just have text as a required string, and they specify that it is markdown syntax. All right. Any other questions about or comments on the assets piece? I'll go try to write this down, Max, and add it to the spec, and then hang you on. Is this what you were saying? Yeah, there's one more thing. So if you have the content string online inline here right now, how would you specify that the content is your eye? So you look at the prefix, if the characters are HTTP, then that is your eye. So you cannot write HTTP in a label of a box. So maybe you need content and then string or content location, and then that's something else. Yeah, that's a good question. Otherwise, it cannot disambiguate. I mean, one way could be that you either fill out content or content URI. Yeah, this would work. I think that's the... Okay, yeah. Text slash markdown. Cool. I like this approach. Yeah, and then the nice thing about this, like we've already discussed, but just to reiterate one more time, is that you can have an OCWGE slash image. Image can handle this way, OCWGE slash text, other things, but other things that might need external assets. Although the interesting thing is you don't even need an OCWGE file either, because the file is going to have some type, some MIME type to it, and some URI and location, that kind of stuff. You may still want to have a file there, but you're not really talking about the asset. You're talking about representing a file preview in the canvas. If you want to have a PDF or something like that, what you're already describing is like, here's a box that happens to have a PDF in it, and maybe the implementation there is more generic to... Yeah, so it's almost like OCWGE slash file viewer is actually the thing you're talking about. It's like this node is a aim to look at a file, so maybe it has a scroll bar on it, and maybe it has the file name at the top of it. That's interesting. I'm just going to make myself a note to go... I looked at this at one point, go look at the set of MIME types supported by browsers. That was super helpful. I think we can all update that and look into it.

Let's see. I think we're at a good spot. Jen, if you wanted to talk about GLTF, you're welcome to unmute, or if you want to point me at something to narrate, either way.

Nice screen share. It goes through some stuff. Yeah, that'd be great. Oh, yeah, I have to stop sharing. Sorry. Yes, go for it. All right, so don't have much time, but I'll just go through some stuff for anyone that wants to do research afterwards, as well as drop some links to working groups. GLTF is described as the JPEG for 3D files. It's a JSON format, and they have an extension ecosystem, which is how... Well, first, there's the base spec. Then anybody can author extensions for additional features, such as there's an extension for different materials. This is KHR dispersion. KHR, the extensions are abbreviated by these things. There's vendor extensions, which usually it's the company or organization, and then whatever it is. Chronos, they have KHR, and that's kind of like the gold standard, because Chronos group, they work on all sorts of various open standards. They're a standards development org. There's all sorts of extensions, and if you choose to support one or not, it's optional, but how it looks in the metadata for these files is something like this, where let me just pull up the JSON example. Here's the KHR for dispersion, and this is a material extension. If I can zoom in here, these are all sample assets. I think also the way that Chronos sets up the GLTF ecosystem is something to be inspired by. As you can see, the extension, and if it's detected, then it's all optional. You can support it, and if you don't, then it's just using the core GLTF thing. All these, as well as the standards development process. At stage one, there is a proposal on outline. You get some feedback on such kind of like meetups that happen in groups like this. In stage two, you want to have at least one implementation, and you also need to have valid and publicly accessible sample assets. It also kind of exemplifies the whole file over app sort of thing. Along with an implementation and something to kind of validate, share some example files and share the JSON schema in a markdown document, which they have a template for on GitHub describing that. Then stage three, you want to have at least two or more implementations of such, as well as GLTF validator implementation. There's some links to GLTF validator and some tools and whatnot that I could drop later. They have a registry for extensions. Here's the validator link, which is also open source. I believe, yeah, it looks like something dragging and dropping. I kind of see that potential in the current JSON Canvas website. It's like something that you can just import and export and test stuff with. Yeah, so kind of figuring out a core spec, and then anything additional and fancy could be added as an extension. If anyone wants to kind of ask questions, do a little bit of research and then ask people that are deeply involved. We have a weekly working group at Omi Group, Metaverse Intrap. It's a bunch of developers from Unity, Godot, Web. All of us just kind of convene on GLTF extensions. We're working on an audio extension as well as contributing towards physics and a whole bunch of other ones that we have here and can kind of see where we're kind of testing import and export between different runtimes and 3D engines and the tooling and whatnot. It was kind of interesting in an earlier presentation here. It reminded me of a lot of conversations we're having in these 3D working groups because we're kind of talking about an interactivity extension currently, which has a lot to do with behavior graphs. Unreal has blueprints and Unity has their own kind of similar sort of node style stuff for scripting. There's a lot of overlap between the tooling for 3D and some of the stuff that's happening in the infinite canvas world, especially the kind of stuff that you see TL draw doing with the kind of turning these infinite canvas tools into programming environments. So worth hopping in just to learn and observe and ask questions. If anyone else wants to I'll drop a bunch of links in the Discord as well as for kind of research later since we're at the hour. Yeah, that's awesome. No, I'll if you drop them in the Discord, I'll see if I can get them into a GitHub discussions as well and see if I can dig into this stuff. Yeah, this looks there's a lot, like you said, a lot of

 similarities here in terms of it would be really nice to have a we had talked about having a NOCWG validator tool online. Yeah, there's a lot we could learn from and that the general it's actually very encouraging to me that the general format of the specification is very similar to the approach that we're taking with between extensions and these different schemas that you can extend the base spec with. So yeah, like I'm sure there's things we could learn there. Yeah, I'll link an example in repo, which kind of shows like proposed extensions in the Discord as well, just because yeah, and they all follow a similar template as all the other kind of proposed extensions. So yep. Very cool. Thanks for sharing that, Jen. That's awesome. Very neat. Does anybody else have questions for Jen about any of that while we have him, somebody who's been diving into this ecosystem?

I thought that Max had some quite good notes there that could go into the canvass. Yeah, it's interesting how they use a more compact syntax for the extension. It's not an area of property bags, it's just special named property for extension points, so to say. And then there's an object behind carrying the properties and they sort of agreed on prefixes to avoid the misunderstanding. So there's a little bit more coordination involved, but they probably gain much better interoperability by doing so.

Yeah, that was actually one of the things that was floating around in my brain, Max, was do we need to prefix properties, property names, to prevent collisions? The flip side of that is if you can use the, and what order would you collapse to duplicate properties on top of each other? Which one is the last writer? Which one wins? So yeah, there's some challenges around that if we didn't do that. Very cool. Okay, we are at the hour or just a minute past. I've got a bunch of to-dos between now and then to update this back and make some and clarify a few things, but this was super helpful. Michael, thanks for building an implementation. That's, yeah, I thought I noted as well that stage one of any proposal was having at least one implementation, like for GLTF. And so that was, yeah, I think we're kind of going about this. Feels like we're kind of going about this the right way. Cool. Well, I will continue to drop information into GitHub and discussion or in Discord as we as we work on this stuff. And we'll, I think we will be on the books for a meeting two weeks from now as well. So great. All right, folks. See y'all later. Hi, folks. Bye-bye.

