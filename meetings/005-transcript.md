# Meeting 5 Transcript
June 4, 2024

Great. Okay. Welcome to open canvas working group meeting number five. And I have, last time we used TL draw to take notes, very appropriate for an open canvas group meeting working group. So I'm going to try that again. Let me share my screen real quick. And I'll also give you guys an invite into this. Share. Copy, share link. There we go.

My favorite part about using zoom is managing all the windows. That was sarcasm. Okay. There we go. TL draw. So you guys should be able to jump into this document. Oh, except this is meeting number five. There we go.

Great. So a couple of things. If you're new here or watching this recording, we do have a website and a discord at canvas protocol.org. You can find almost everything linked from that. But our source of truth for things is GitHub. So we have a set of GitHub discussions at github.com slash ocwg that has basically all the conversations that have happened around the spec for the last six weeks or so, six or eight weeks. And then we also have a draft spec now at github.com slash ocwg slash spec. It's nice to have these four letter words.com slash ocwg slash spec. So you can go check that out. There's a pull request there. And that's where we'll be iterating on this.

But I'd like to start off with introductions for folks. If people don't mind introducing themselves, they're welcome to the folks who have not been here before. And then we'll jump into agenda items for the call for today. I think Luke, this might be your first meeting if I'm remembering correctly.

It is indeed. So I'm Luke. I'm the CTO of a company called ScreenCloud. That's a digital signage company. But I've recently been working a lot with TealTraw. And I'm looking to build, I guess, this cross-treater browser and operating system that runs is able to load things locally. So a bit of a weird concept. But I'm basically here probably more of a fly on a wall. I'm just kind of curious what you guys are working on. And I guess my belief on this is that I think there's some really interesting stuff going to grow out of this space. And I'm just sort of following the space and all the people in the space to try and just kind of watch the direction things are going. Yeah, I think the web needs to evolve. And I think that there's a direction here where, you know, a lot more can grow out of infinite canvases than just documents.

Yes. Yeah, definitely. You're in good company. Thanks. Yeah. And totally, lurking is a perfectly acceptable way to hang out in these meetings. So and I think, John, this might also be your first call. I recognize your name, but I can't remember if you were on one of the early calls or if I just know you from the interwebs. John?

Yeah, I was in the first two. I missed the last couple. But glad to be here to watch this again. I'm working with Chris Schenck on a number of projects. But the one that most directly connects right now is our work. I'm looking at the DOM as a substrate for live programming and using web components as a tool for, you know, introducing lightweight, diagramming, and extensible diagramming.

Cool. Yeah, that's a really cool project. All right, I think everyone else has been here before, but feel free to introduce, like, interrupt me on mute and or use chats to, to say who you are, if I, but I'm Steve, I know I've seen you before, Michael, Max, Allen, obviously, Orion, and then, Jen, I believe you were here last time. So I'm going to keep going and we'll see where we can go.

So Orion and I have both been to Berlin and back, have crossed the world and returned for a local first comp. If you guys haven't heard of local first comp, it happened last week in Berlin Thursday and Friday, local first software based on the Incan switch article, and conference was great. But importantly, Orion and I got to validate the fact that we are not actually manifestations of an AI, but we are legitimate humans. We were able to shake hands, hug, sit down next to each other around a laptop and type things into the laptop together.

And yeah, it's been, it was great. So we, we took the opportunity to type up our thoughts on the initial spec. Like I said, not everything is in there yet, but we were able to like hammer through a lot of the things. And that's where the github.com slash OCWG slash spec. And that's what I'd like to spend most of the time discussing. I have an alternative thing that another agenda item that I had wanted to discuss of like how to set up a test bench for this, the whole like running software Trump's documentation idea. And I have some thoughts on it, but I'd really love I'd love for, yeah, other people to share how they might set one up.

Jin is adding his introduction works on interop in groups mainly related to 3D formats. Awesome. Yeah. That is great. That will be really helpful. Canvas for 3D. Yeah. Well, you'll notice in the spec that we've written, we put an optional Z parameter for nodes. So not required, but want to be able to support 3D canvases as much as possible.

All right. That's pretty much my whole intro. And then I'd love to talk to things about the spec. But does anyone have things that they want to discuss that are not either the draft spec or the test bench, we can make sure that we can serve time for that. Because the purpose of like doing these synchronous meetings is not to like try to nail right all of the spec in this meeting, but to make sure that things that require synchronous conversation are not required, but benefit from synchronous conversation. We can have this time once every two weeks to do that. So if people have stuff that they really would benefit from talking about, happy to add that to the agenda. Feel free to, I love how people are just jumping into the tail drop. So feel free to add your agenda item here.

But Orion, before we dive into looking at the spec, I think you were talking earlier about some things that are not in the spec that you might want to at least say we're going in there. But is there other stuff you wanted to talk about today as well?

Yeah, I think most of that stuff will come up as we go through it. But basically what we've tried to nail down or at least draft out while we were in Berlin is the file format. But that there's a bunch of stuff that's missing from that. For example, where is the origin for shapes or what direction do the coordinates go in the canvases? And that's the kind of stuff that we'll need to flesh out and decide on to get like a full spec. And yeah, what we have now is really like the shape of the data that would be in the file and kind of what the schema of that file takes. And it's missing some of those specific decisions on like how we're encoding specific information, coordinates, stuff like that. Yeah, we'll talk about that as it comes up.

Cool. And there is a GitHub discussion post on that specific thing, I believe. I think probably the most useful one on that one is the OCWG comparison table that Orion worked on actually has sort of canvas sizes, renderers, coordinate systems, coordinate orientation, discreteness, that kind of stuff, and has a comparison of a bunch of different tools that you probably familiar with. So if you're curious about that specific thing, feel free to check out this table.

While we were writing the spec in Berlin, we were actually pulling up different canvases write ups. So Steve, I believe you did a write up on Swibbler that you posted, which was very helpful. Thank you. And yeah, we had some other individual fields that Excalibur, the Excalibur write ups were also super helpful. If somebody went through and like documented how Excalibur stores arrows, how it stores text, how it stores all that kind of stuff. So trying to come up with a sort of least common denominator for each one of these items that would support kind of broadly the features that are available in the different canvases.

And we'll, if you have other canvases that you think we should be keeping in mind, feel free to like chime in, but we got a bunch of them there.

Okay, I think the thing that's most on my mind is the extensibility section. So the way that we're extensibility seems like the hard problem to solve here when you're supporting multiple canvases, especially when you're supporting a range of canvas types. We want us to be able to support things all the way from the sort of conceptual canvases where the relationship between the objects on the canvas is the most important thing, all the way to canvases that are more about the visuals and where things are placed on the canvas relative to the other things, the visual fidelity is more important. We're probably going to cut off either end of those things of like not, it's not, this isn't all about supporting property graphs or like other, let's say like purely conceptual formats that are really about purely conceptual, the purely conceptual world, all the way to we're not supporting things like Figma, Fig Jam, that kind of thing where it's like visual fidelity is everything and getting the visual fidelity perfect is really important. It's kind of like use property graphs on one end, use SVG on the other.

And I really like when people have been asking me what I'm working on this, I often just say it's markdown for canvases. And I think there's one really important thing from markdown that I think is sort of conceptually what we're trying to do, which is markdown does not support every single feature of rich text, right? But it's a sort of lowest common denominator

 that's available pretty much everywhere. And that is what this spec aspires to be is the thing that's available everywhere that supports like the lowest common denominator thing that will allow you to transfer between different tools that have very, very different feature sets.

So that being said, the extensibility piece is key because we do want to allow the, this is like markdown plus extensions. This is like something markdown doesn't have. What ended up happening in the markdown world is you have things like GitHub flavored markdown and all of these other proliferation because extensibility wasn't designed into the original markdown spec, you basically have people coming along and saying, well, I really think markdown should support underline. And they're like, I'm going to make it these two random characters wrapping some span in order to support underline, even though that's not part of the initial specification. So we're trying to go a little bit further than markdown here of like trying to think ahead about extensibility. And the way that we've imagined doing this is through what we're calling schemas, where every object in the, every object will be defined by a schema. That schema will define a set of properties that are on that, on that object that are in addition to the base properties. And then we would have a set of basically you would include the schemas at the bottom of the file, along with the nodes and relations. So you have to, you actually have to embed the schemas that you're using in the bottom of the file. And that allows people to be able to interpret the file and interpret the schemas, even if they don't support them.

And then I think the more interesting one is something that I think this was new as a Berlin, or maybe it was something you were already thinking about, Orion, is schema extension, where one schema can extend another schema. And you basically have additive like properties, you can add additional properties, which is kind of an interesting way of handling it. Any questions about like extensibility? Or did anybody read this section and wonder about things or come up with cases that this might not support or things that this might cause to break?

I have a specific question about something that I'm wondering about. But I wonder if that's part of the extensibility part. It's a put it on the agenda just now. I am building, I'm looking at it from a visual programming perspective, mainly node and wire tools. What you see often in those tools that they have ports to which you can connect the nodes. TL draw, for example, when you connect nodes, they are always connected from a point in a node which you can control to another node. And I also think that's currently how it's specified in the spec. So I was wondering if you want to influence that, is that something that should be part of the spec or something that more belongs to the extensibility part of the spec?

Yeah, so this is like thinking off the top of my head here, but I believe the way that I would imagine one thing it's really important that may not be as clear unless you like squint at the spec right now is that we have separated the idea of how two nodes relate from one to one another, and then how you visualize those relationships. So in other words, you can have a relationship between two nodes, an edge, which we have like we laid out down here in the, or I think in the relations section. Hopefully I didn't cut it. Yeah, here we go. There's basically three types of relations that are sort of part of the core. There's sets or groups, like you can call them a set or group. That's one type. There's edges, and then there's hyper edges. And in order to say that this object relates to this other object, you could make a relation between the two, an edge relation. Now, that does not mean that that has to be visualized by an arrow, by anything additional. In fact, if you have a canvas that is drawing an arrow in addition to that relation, then they would need to have add two things. They would need to add a node of arrow type that goes from one place and points to the other, and then a relation of, here's how these two things are related. And our vision for the extensibility is exactly that you would extend the edge to describe additional attributes of the relationship between those two nodes. So if there was, if one was a computation target for another, like whatever this, whatever the computation in node A performs, it will update node B or something along those lines, then you could create that as sort of like a computation edge that extends the edge, the OCWG edge specification, and add some additional properties on that, that maybe it spells out what the computation is or that kind of thing. But again, that is the purely conceptual part of things.

It sounded like when you were talking about ports, you were actually talking about the visual representation of like this arrow comes into the right side of this square, kind of like I've drawn right here. Is that what you were referring to when you talked about ports?

Yeah, both. It can be something visual, but usually also port has some has some meaning, like if you have a react component, you have properties, and node can also have properties which have different types. So a port can receive a value, you can have another port which receives a different value, and that type of node adds those two numbers together and outputs the result, for example.

This was a plus motivation behind having like schema extensions, so that you could, for example, take a base rectangle schema and extend it with a typed ports schema that would say this rectangle can have some list of ports, and each port has its, you know, it's like part of that schema. So you can say it has to be, it has to have a type, and the types can be, you know, number, color, and vector, or whatever it is in your system. And the nice thing about that is that another tool that didn't have that would still be able to treat it as a rectangle if they shared some base schema, even if they wouldn't understand how to wire up edges to ports or what those semantics were doing.

Or you could do it completely differently, just have one rectangle, the ports are other rectangles, and then you have a set relationship that the rectangle contains the port rectangles that could be even more interoperable with other tools not supporting special schemas. And I think this is an important thing we should kind of discuss, if there are different ways to model stuff in Open Canvas, what is a good way and why is that a good way? How can we find rules for using this quite extensible spec?

Yeah, let's go to Steve and then John.

Hello. Are you hearing me? Yep. Okay, great. Yeah, my concern is with this schema. It seems to be very verbose. It has to be included in every single file. It has to be parsed every time you read it. And I think it's all to support this idea of inheritance, because you know a TL draw arrow is like your some defined Open Canvas working group arrow. If that information could be encoded in the name of the schema itself without actually referencing the schema, then we could like read TL draw arrow and know that it inherits from the arrow that we know about already without having to parse and manage all this complicated schema within the format itself. That's my main concern.

Yep. Yeah, definitely. I share your concern, Steve, around, and Orion and I went back and forth on this of like how to, because you're exactly right, the core driver here is supporting inheritance. And the thinking, and this might be part of me thinks that we've already gotten too complicated. And John, we'll get to you in just a second by even having this idea of inheritance, but why support inheritance? The why would be it allows for another form of fallback, meaning if a Canvas doesn't support TL draw arrows or doesn't even know about TL draw arrows, but the TL draw arrow inherits from OCWG arrow, then because the TL draw arrow is a guaranteed superset of OCWG arrow, then an implementing Canvas can say, well, great, I'm just going to take that TL draw arrow and display it as a standard OCWG arrow. And I'm going to ignore all these other properties that are on the TL draw arrow. So you get this that you can walk back up the inheritance tree for the schemas to find a simpler one that you actually know how to do things with and then kind of doing with that. But I don't know if I actually understood your suggestion, though, in terms of it doesn't sound like you were saying that inheritance is a bad thing or that we should not include it. It sounded like you were saying a way that we could potentially encode it in the file to make it easier to parse. And I'm not again, I'm not sure I understood what your suggestion was.

So when I see I'm looking at this back and I see schema TL draw arrow. Now, if we can include the in that name, the complete inheritance path itself, then we would not have to parse all this whole schema for just to get this inheritance information and know that it's actually an arrow. Like you could have TL draw slash arrow, and then, you know, have some other symbol and say, Oh, this inherits from open canvas working group arrow.

Yeah, so we did we did look at one representation where you would have where a schema could either be a string or an array of strings, right? And the idea that would be you'd have, you know, an order of like this is OCWG arrow, then TL draw arrow. And so the parser could just, you know, check them all until it doesn't understand one and then stop that basically. So maybe that's one reason to do that. Either way, it is often going to make sense to include the schema information somewhere in the file or even the fragment if you'll copy pasting. Because that gives us a port a kind of portability without having to, for example, have like a schema registry and do fetch requests for the for

 the schema every time that the action happens.

Well, yes, and I understand what you're saying now, Steve, we have we actually did have different when we were writing in Berlin, we actually had different formats that we were looking at for how you would specify inheritance, one of them, which like you mentioned, just have the entire inheritance path right there, basically right here where schema is specified.

John, do you want to give a question or comment?

Yeah, I mean, I guess I had a thought on what Max was talking about earlier, but just touching on what was just described there, it is interesting that there's sort of a question there principle about like, do you have to go out and retrieve, you know, the latest version of schemas, how do you obtain those schemas versus what he was describing there, like maybe you know about certain schemas, and those are embedded in say your Swift app instead of thinking solely in terms of, you know, web always fetching, you know, latest schema. I guess the thing I wanted to react to earlier, you know, Max and the prior conversation that there's sort of this wicked problem of modeling, that the whole node and relationship thing is really interesting, but there's this principle there you wanted to have, you know, different tools can ingest this, and they can interact with it, persist it back out, and they don't negatively affect information that was previously persisted by some other tool. And I think the one that's going to be interesting there is like the notion of a few delete something. And we've got these extensible schemas and those reference nodes that might be removed or added. And so I do wonder, like, how do you square that? Have you given that one thought?

That one came up in my shower this morning, after I had written all this stuff.

My best thoughts, too, yeah.

I managed deletion, like, I was hoping one of you would have the answer for that.

So one thought I did have, which I don't love, is basically having a nodes list that you maintain. So we have, so that would be an additional structure here, or a, you know, objects list or something, that basically just is an array of IDs. And so if you notice, like, ID is part of the node and relation spec. So if you had a list of IDs and you were deleting something, you would just remove it from that list. And then you could do things like intelligent merging, knowing that, like, nope, that object is actually gone. It's not that we didn't understand about it, understand it, or we dropped it on the floor. The objects list, the list of IDs changed. And therefore, we can know that it was removed. Again, that was my initial thought this morning in the shower. I would love this. I agree. I think you nailed it. Like, this is one of the hard problems of the, and I mentioned this in the spec, too. The most onerous part of supporting open canvas or supporting something like this is that implementing canvases have to store the data that they don't even need or even recognize such that when they write the open canvas file back out that any nodes that they don't implement the feature of or whatever, it goes into that canvas file, goes back into it. But then, like you mentioned, they also need to differentiate between I don't know about this item and I'm putting it back in or I don't know about this item, but I drew a fallback on the screen and the user deleted that fallback or the user attempted to delete all objects in here and start with a blank canvas and then building back up. And so I actually need to delete this object. It's kind of a tricky problem.

Yeah, I think the thing that's hiding in there is the notion that you might be tempted to put relationships into the schema when that really should be managed as the first class feature of this system in order to sort of maintain that health and make that be the happy path that people fall into rather than hoping that someone is able to adjust things that they don't have that control or awareness of or have any heuristic about how to do what they should do so that schema when something's removed or added.

Yeah, that's a good point. It is a, it feels like one of those things like Max was just saying of like there will be many ways to do things with open canvas as opposed to one way, which is always perilous. But if there are going to be more than one way, we need to actually tell people what the recommended way is to do it. It's that tradeoff between extensibility and clear one way to do things. Alan, you raised your hand.

Yes, thank you. So lots of questions. Love what I'm saying, but skipping all of that to go to the, to kind of jump into the second agenda point, which not to change the course of the conversation, just a couple of quick questions, maybe it'll lead into that. But I'm really curious, I'd almost like to see like a spec for what's involved in setting this up. How flexible will it be once it's like testable? Is it kind of like, how important is it to get everything right right now versus let's just assume that you have it all figured out and we can break it as we go? Does that, is that, is that a bad way to go about it with, with what you have in mind? And then it, you know, if it isn't, then what, what do you have in mind for how we can break it? You know, like, are there two tools that are really notoriously opposed to each other? And we just really like to figure out getting a working example going.

Yeah, a couple of thoughts on that. One we decided, not one approach that we're taking here is actually choosing two tools that are very close to one another and trying to get those two working. And so, Ryan's working on an Excalidraw TL draw sync. So Excalidraw and TL draw have pretty similar feature sets. And just getting, getting anything working I think will be a way to start to work through some of these problems. So I'm very, to your, your original point of how much do we need to write down, get it all, get it all correct in writing versus just like building a simple prototype of it and then trying to break it. I think we're trying as quickly as possible to get to working software while also maintaining a document that represents what's happening with that working software, right? So it's kind of like figure out what happens in the prototype and then go update the document to reflect that. And as we run into problems like John was just mentioning with Deletion, here's how we can work around that. We could try several different things. We might end up with, you know, four or five things that go into and out of the document as solutions to things we come across as we're building a prototype here. I would love it if someone else wanted to do something more across two more diverse tools, like if Michael wanted to do a CodeFlow canvas to TL Draw Sync. Those two tools are pretty different. We'd be happy to support someone that is going down that path and that would certainly pull the spec into divergent directions, which would also be, I think, very valuable.

I've already been looking at that, but I haven't coded that anything yet. But this, the point that I just raised is my blocking issue currently.

With ports? Yeah.

If you have several, if that's the blocking issue, I think we could propose one, two or three different solutions. One of the ones was what Max mentioned of like, actually make ports their own object that you could then connect to. And then I think another approach would be extending the OCWG rectangle and add another property, a group of properties in the properties bag called ports. And then basically tools that support ports. Because I think ports is actually supported by more tools than just node and wire. So it just so happens that TL Draw has a very funky way of connecting an arrow to an object. And Orion and I spent some time debugging how they do that. But we could look at ways to, we could make several suggestions that would unblock you there. And then I think it'd be just interesting to map that back and forth with TL Draw and see what breaks in the process, where the loss, lossiness is. I actually liked what Max proposed. That's actually what I do myself when I use TL Draw for thinking of concepts about my own tool. Then I draw little blocks on other blocks, just like this. I just draw other rectangles on small rectangles on the sides. That makes sense. I probably need some adjustments in my own tool. So I'm going to think about that.

Yeah, that's cool. One of the things you could take a look at is we did talk about using having a relation that's a set. And that set could basically be a group that keeps all of these things together. That way, when you do pull it into TL Draw, it's already grouped. And then you can drag it around. Well, I missed the group. You'd be able to drag it around like this, which would be pretty nice. And then the other thing is you could have the arrow point at the port or at the rectangle there, whichever one you're connecting to. And then you would get nice TL Draw arrows in that way. Actually, kind of cool.

Great. And as John pointed out, this would be the only way to keep references intact when working in another tool and importing big.

Right, right, right. So you're saying, wait, how would it be the only way to keep? Maybe I'm not understanding what you're saying.

Well, if we have an extended rectangle type with our custom properties, any tool not understanding this particular special type cannot know if we delete something that this property needs to be updated. But if a port is just a regular node, and we know this is a node with an ID, we manage the ideas in the interrupt space,

 then referential integrity can be kept.

So that's like a guideline when to use what have managed ID. So use a node. Use as many nodes as you can sort of in order to profit from having node IDs being managed. Does it make sense?

Yes, it does. I'm trying to generalize the statement. But I think if I capture it here, I should be able to work that into a sentence or two that I can drop into the spec and then say, does this describe what you're saying? Yeah, Alan, feel free to go, bud.

Yeah, just a, I wasn't fully following the maybe misunderstood the relations talk earlier about how relations is part of the object and it doesn't necessarily mean an arrow. In fact, an arrow would be a different node. If I have that roughly true, then could ports be kind of like relations that don't have to have an address? Could you have a relation as part of an object that can be empty? And if it's empty, it's kind of just like it could default into a port. It's basically saying a relation is sort of the same thing as a port, whether it's used or not. I'm throwing that out there. Just forget about it. It doesn't make any sense.

Yeah, I think so far we, I think somewhat nicely only really have two things. We have things that need to be visualized, which are nodes. We have conceptual relationships with each other, with other objects, which don't have to be visualized. Now our relation can be visualized through nodes and a node can represent something that is not a relation at all. Even an arrow between two things cannot imply any relationship between those two things. And I think those two bags of things, so maybe is there like an empty relation? Is that what I thought you might be proposing?

Yeah, I was trying to, it was something that you said earlier along the lines of the ports are or could be construed in a way is just like little objects grouped onto a larger object. Right? Well, what is the ontological equivalent or semantic equivalent of that would be almost like maybe open relations or I'm still kind of thinking it through. It doesn't quite connect, but I saw some for a brief second, I saw a connection between relations and ports.

Sure. Yeah, almost certainly Michael's going to want to represent relations between nodes using those relation objects because that's the sort of conceptual thing that backs the, yeah.

Great, thanks.

I was just, John, I see your hand. I was also looking at Jen's comment. This talk reminds me so much of GLTF extension meetups. GLTF is like JPEG, but for 3D models, it's JSON and extensible. Ooh, that's something to go look at. That's interesting. GLTF extension meetups. Yeah, that'll be really interesting when there's a actually open canvas schema meetups where people are like co-writing or like each writing their own schemas for to extend open canvas.

It's something worth looking at. John, go ahead.

Yeah, just a random spark of a thought. I don't know if it's a good idea or not, but we're talking about this notion that nodes can depict entities that are out there and then we might have some other nodes that represent how those entities are connected, like an arrow, which makes me wonder if relationships should not only just have Brahmin 2, but maybe it should have one that is depict, that it is the thing that depicts that relationship within the visual medium there, since you've got that distinction between the visual nodes and the underlying relationships.

Yes, you're right, John. And Orion and I talked about this and it never got written down. But basically, yeah, we need a pointer between an edge, like I think we called it represented by or something like that, that was a pointer on a relation that allowed you to say this object represents this. And then we basically just need two ways such that if someone deletes one, they can delete the other. We can delete the other automatically. Deleted the arrow, then it deletes the relation, that kind of thing.

Yeah, thank you for mentioning that. That is definitely a, I'll make a note in my document over here, oversight. I'm glad that you guys have already brought up some of the hard problems that have occurred to me while I've been doing this. It would be great if you brought up some hard problems that haven't occurred to me yet, so that I can, not that I have answers to the ones that I've come up with. But I don't know if it's appropriate to jump in and say this, but I just think there's an awful lot of things that can be put on one of these canvases. I mean, we see we'd like make real and things that you can, you know, everything from an embed and iframe, a react component, you know, an ESM module rendered to .omelement or something like that, or web component, all sorts of things. And I understand that the specs, probably you extend it in lots of different ways to cover these and the kind of base level things are things like lines and arrows and text and things like that. But I just kind of wonder how much people are thinking about that, or is that kind of like, I guess, out of spec in a way? I just think that this is going to grow to have so many, like I almost think of canvases as being a kind of new type of web page or markup document, if you see what I mean. So in the same way that, you know, HTML has grown to have many different elements and, you know, that maybe you end up kind of, in the distant, well, maybe not too distant future, do you end up with lots and lots of different things that people will be embedding on canvases? And to just kind of like, well, maybe it comes later, not needed in the spec, but like the kind of base elements for components and things. Do you know what I mean? Kind of, there's stuff that's part of what I would, everyone would consider a whiteboard or a canvas, and then there's stuff where that sort of starts to kind of go into the world of components and pieces.

Yeah.

Maybe that maybe that doesn't apply. I don't know. I'll just kind of speak my mind.

Yeah, no, it's, yes. So the the general thinking here is that there would be potentially something like an OCWG slash star namespace that you would that would have sort of the core and then everything else, like embeds and all those kind of things would be able to be handled via extensions. And that that's exactly, I think we have the same intuition that you have that you can use these canvases in so many different ways and then put so many different kinds of things on them. And we want to enable authors to kind of do that. And so HTML is actually very much an inspiration for us. We don't want anything as quite as complex as HTML and CSS. There should be like, this should be a flattening in the same way that marked down as a flattening of rich text. And the but the extensions would allow you to represent lots of diverse let end in authors to represent lots of diverse things. And then the the mechanism for that would be including those schemas in the file itself for now. Maybe eventually there's some schema registry or whatever that way each one of these files is a self contained object. There are self contained files that can be passed around and would anybody that knows how to parse JSON schema formatted items in this schemas section would at least know how to parse the file, even if they can't even if they don't support those same embeds.

Okay. Yeah, I agree. This is a yeah. Feels like there's going to be a lot of a lot of things here.

Alan, before you go just sec, I'd be there was actually I'll let you go and then I'll I'll say what I was going to say because you might want to chime on to what you was going to say.

Yeah, well, it's another one of the hard problems if you're asking about so I can wait similar to what was just brought up in a kind of an example on the canvas that we're working on. Definitely not a near term or PO, you know, MVP kind of thing, but maybe more important than we realize. But I can I can wait if you go ahead.

No, that's fine. Okay. So the thing that I was seeing that might be more important, I was thinking about in terms of contexts, right? So there's a lot of different players on the board right now, and they're kind of working with a different tacit mindset, right? So in particular, there's an example of open file format, infinite canvas data. These are these are screenshots. Two of them are connected by a pointer. But one of them is just connected by proximity. And that's like a single context, right? So even though it doesn't have a it isn't, you know, semantically or sort of ontologically connected, there's a in that case, a an actual coordinate proximity, then another context would be sort of like my little scribbles over to the side, which really don't have anything essentially canvassy about them at all, they could be completely reduced into text. You know, they're just notes and minutes, right? That's a different kind of context. I'm bringing it up because it's kind of like, if there is something there, then your your interop schema could go could have parts of it that can be translated outside of the canvas, right? Parts that are just like, hey, it's better to treat this as a screenshot. I'm not even going to try and turn it to opml. But here's this other part that will work. So I don't know if you've thought about that. I don't think it's definitely, you know, near term. But yeah, the the way I understood you, the way I yeah, my interpretation of your comment or slash question is that a specification like this could end up being used in not just a variety of

 different canvas tools as an interchange format, but in a variety of different ways, including like one of the things that was important for me in terms of representing this is JSON versus say XML, is that JSON is reasonably human readable slash editable, right? I can I can open up a JSON file and like see the the list of nodes and go, those are nodes. Those are things that are like on the canvas. And then I could look at a node that has text in it and then see the text field and go, I can kind of picture that like that's a that's a text node on the field or I mean on the on the on the canvas. And like even though I can't certainly reconstruct the entire canvas just by reading in my mind by reading the the file format, I can reasonably know what it contains, whether it contains relationships with between objects and things like that. And so that human readable part that would be a different context than like executing this within a program, for example. But then another one of the other thoughts that I've been having to is that I'm working with a tool right now called Composer, where we have both whiteboard like sketch type objects and documents. And what I want is the ability to open all of the text objects in TL draw as documents and use a proper document editor for editing them and then have those things update automatically inside of TL draw in the in place where they are. And so I could I could see something like that happening here too, especially someone Jen was mentioning in the chat of like supporting markdown as one of the text formats. I think that you could open being able to open this file in a text editor and then have it like list or have some sort of like list all of the text objects and all of them are you know able to be individually edited and then say back out would be an example of using the the thing in a very different context but would still be useful.

Excellent thanks. I'm noticing we've got about eight minutes left. I think unless there are any last minute comments I think I might like move us to like agenda like wrap up next steps that kind of thing talk about what we're going to be doing over the next couple weeks. Does that sound good to people? Any last minute questions?

All right. Cool. See at least one last question I do. What's the exact idea behind OCW asset because I noticed that particular type has a mime type. So this looks a bit like a double extension mechanism. Can I put a PNG in there? Does it make sense or what's the intention really?

Yeah so that was a I'm glad this is exactly what I was going to bring up before Alan asked his last question because I feel like it's also we talked about this a little bit last time and maybe two times ago. I'm trying to remember when it was exactly. But yeah the thinking here is that anything that's an embedded object an asset that is not native to a canvas. So an image, a video, anything like that. We were thinking about just generically supporting whatever mime types are available in the browser. So yes it would be image slash PNG, image slash JPEG, that kind of stuff. And then how we would, this is where I started thinking about what you mentioned earlier of like multiple slashes to delineate the schemas. So it'd be like OCWG slash

to make the question simpler. Let's say I have a canvas tool like obsidian and have a markdown file. So this markdown file is a file I side loaded next to my JSON canvas file. So it's kind of an asset that has a mime type and everything. But it's also in the canvas so it should instead be another type. So there's some duality of being externally like location and the type system and they are a bit mixed up right now.

Yeah agreed. If you have suggestions here I'm open to them. This is another one where as I was writing it I saw. Yeah simple suggestion would be to say you have nodes, they have a type and then they content is either inline or they are content is externally. So you have a locator and that's basically it.

Gotcha. What else in here would be to have like an OCWG asset schema but not treat that as a type, right? But you take something like a rectangle or whatever the thing is and then you extend that with the asset schema that would basically say like hey this thing, it has a mime type and it has a URI. Do what you want with that information. Because I think part of your point there Max is that like OCWG slash asset here is it's not talking about what the shape is in a sense, right? Like it's not saying this is a video shape or something like that. It's about where the where the data is.

Yeah.

I think it might be a little complicated. But this needs some clarification. I think that's a good question. Yeah. Let me update the spec with what I was like a more complete example or several examples of what Orion and I were thinking of here and then maybe we can look at other ways to represent it. I hear you correctly put your finger on another somewhat hard problem and that's exactly why I came and highlighted this section because it was a trigger for me of like if we have a few more minutes I want to talk about this. Well Jen has like offered to talk about some of this stuff. So Jen do you want to unmute? I don't know if people have been following the chat but he's been posting some great stuff about GLTF which I read but also some other stuff as well. So Jen do you want to talk about the stuff from the on the canvas?

Yeah. Can I screen share? Yeah. Absolutely. I mean stop my share and enable screen sharing via the little most of tools I think is where they hide it now. There it is. All right. Now you can.

All right. This is working. It's basically a pipeline for dog fooding some of these things that I noticed we're already doing you know in the course of this meeting but you know how can we extend that with the meeting notes from Zoom. So we go from these transcript files which they're VTT and we made a VTT summarizer using Golama so you can just download some open source AI models that can create some really nice bullet point summaries and then those can output into we have some prompts for outputting into JSON as well as markdown. So we go from videos transcripts okay and that can help us kind of like post some recaps. So it just kind of like helps save time and you know we get some nice summaries of recaps from the meetings and then I have a script that grabs the JSON from GitHub discussions which I posted in a general channel so we go from GitHub discussions to JSON canvas and then from there yeah well we don't have this yet so like that would be really cool if we did. So imagine we take GitHub discussions JSON canvas can we go back to markdown can we round trip from Canvas back to markdown vice versa and then I'm working on some things using like I have this other kind of pipeline for taking screenshots from various sources including Zoom where these panels are generated from markdown to HTML and then I screenshot the HTML and I bring them into Blender and export 3D objects so just kind of building building blocks to construct memory palaces and war rooms so that in the future our meeting spaces can become kind of more immersive with our notes and activities and discussions from previous weeks you know and that can help build a longer term sort of memory for an org help with on ramping help with kind of seeing a bigger picture new connections and ideas from previous meetings versus kind of how they're kind of separated you know in these tabs you know can we spatialize these tabs out you know project the canvas into the 3D space another cool thing that would be interesting to dog food is like going from canvas to 3D force graphs so this is a really great get hub repo and I think it would be fun to do some kind of hackathon where you know we just like experiment in all the different recipes we can cook this data with you know canvas being the grill you know for all the different concoctions we can create with it.

That's fantastic. I'm definitely stealing that analogy of I'm going to cook this thing with the canvas being the grill. Very word picture. So it's funny that you mentioned like this part right here that you were just showing with the VTT the YouTube the all the way that that is literally what I do after these meetings like I download the Zoom recording I use whisper to transcribe it I feed the transcription into chat GPT and ask it to generate like discussion summaries discussion summer and then Orion and I jump into a shared document editor and we edit down that summary until like the things that are left are there and then we post it to get hub with that that's how OCWG meeting number four came to be was like so having a pipeline like this would be really really helpful and the other I guess the other piece I would say is that like this idea of workspaces that accrete knowledge over time where we can come in and work together is very much my jam I've been working on a bunch of stuff in this space for a while and have been following people on this and so yeah I would be I would be down for that kind of those kind of meta things that we could do to make this more effective and that was actually one of my motivations in starting to use TL draw as a at least a place where we can have meetings so you can actually go up to the TL draw picker at the top of the canvas that you're in right now and there is an OCWG meeting four and so you can actually go to meeting four and there's there's all the notes and the the scrawlings that we all had here but it would be nice this is a pretty anemic relative to what it could be so I think the other piece here is that one of our goals with this interchange format would be to enable little tools, like force-directed layout tools and that kind of stuff, to interoperate with things like TL Draw. It shouldn't be the case that every canvas has to add every single possible feature and variation of features and support really crazy force-directed graphs and all that kind of stuff. We could actually have those be utilities that, if you could export from your canvas, bring it into this utility world, run that utility, and then bring it back into your canvas, we could maybe make small software that does really helpful things for you without having to bring in a library to TL Draw and all the other things there.

So I think what you're showing is very much aligned with the vision of the project and certainly goes beyond it, but I think it is in the same direction. This is exactly where we want to get to, so it's exciting.

Yeah, just trying to find ways to reduce friction, like breaking out the tabs into a shared space can be done in 2D, but this is kind of what I'm working on outside of meetings as well.

That's awesome. That's helpful context. Glad you're here and tagging along. Definitely let us know if there's any way that we can be supportive of the stuff that you're working on as well.

Okay guys, we're a few minutes past our stop time, so to try and respect folks' time, we'll go ahead and wrap up here. There are great questions, and you guys are putting your fingers on all the right things that Orion and I need to figure out and wrap our heads around. But also, the spec is not ours. Feel free to leave comments in the GitHub pull request. I did see a pattern on the JSON spec where people would do a PR against that branch if they had a larger change that they wanted to recommend. So if a comment is not a great way to convey your thinking, feel free to open an entire PR against that spec branch, and we can review your larger changes as one group if that's helpful.

But yeah, I really appreciate the thinking you guys are doing around this. We're also going to try and be more on top of things now that we're not traveling. We'll try to get the recap posted a little sooner, get the notification about the meeting two weeks from now posted sooner, and that kind of stuff. That way we can keep things moving along.

Thanks y'all.

Alright, we'll see y'all in two weeks, and we'll hear from you on the internet.

Thank you everybody.