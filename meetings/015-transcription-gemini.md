Okay, here's the transcript broken into paragraphs based on speaker and topical shifts:

All right, here we go recording OCWG meeting number 15 and yeah just the recap of what we've been talking about so far. Max has been working on getting the spec 0.2 merged into the main branch which will basically be this point I think spec 0.2 would be a spec that could be implemented, like we should try to implement it at this point. Not that I mean Michael, you've done some implementation with the older spec, but as more of a proof of concept, I think we're ready to actually give this thing a try. So yeah, for sure Michael have some comments on Max's PR which we're gonna go through real quick. So go to Max.

All right, excellent. So we have first you know let's start with the same point rotation sort of the rotational center of the note should logically be the same as the point that is used for positioning which in the spec we said is I think top left because that's apparently the standard in this tool space. So if top left is the point you position then probably that should also be the point you rotate around rotation and I'll just add change that in the spec I took a note.

Then about the styling, I added some weird CSS and I'll just remove it no problem. And then about the resources and last time we already had some discussion about things with an ID. So if we address stuff by ID why don't we put it in a map.

This is, yeah, this is an aesthetic problem, not so much a technical one. So I found, I found an argument why putting it in a list might be better. If we have two files and merge them or we have one file that we manually mess up and accidentally introduced the same ID twice and we parse that file and the usual parsing technically will be adjacent parser parsing it into run and then some other code looking on the JSON and trying to create useful in memory data structures and actually throw validation errors like here you have a note with the same ID twice and that's not allowed in the sort of fix that blah blah.

But if we use a map then the first JSON parser will say this is illegal JSON you have the same object key twice and of story and then there is no useful validation message because it's already technically structurally broken and so due to the reality of how this parsing works using arrays with an ID field will result in better validation error messages it's not a strong argument but it's one I yeah sounds good.

And in the simplest case you can just a very simple logic here when combining two files is just concatenate all the arrays yeah and you know don't do validation or you know like that you could you could cross your fingers you know yeah exactly it's probably it's probably gonna be invalid and you want to run to a validator but you could at least there's a simple algorithm for that will guaranteed no conflicts of just concatenate the arrays.

But the spec has covered your back because we say the ideas should be unique and if they are not unique we take the first one and so we are not dying at least we suggest that implement our syrup up die yes but they should just render something weird and show an error message so it's more like yeah it feels like the HTML approach of like way to browsers go to great lengths to render broken HTML yeah even though we all know it shouldn't be formatted this way or that way or the other yeah well we'll make it work.

Yeah for the notes we discussed earlier some some meters ago the order of the of the list is also the order how it's rendered at least the fallback set order yeah although you also can use this that index for that I think yeah and it's also and actually you can do the same with it if it would have been a map with yeah just same with what if it was a map also it can also use that same order. But this is this is even more tricky because it's now a jail JavaScript standard that maps have an order, but I think it's not a JST and that JST maps have an order.

So if a JST map is by default an unordered bag then the JSON parts are might show it in any order like if you use for example a Java map the hash map behind the scenes and the order is actually not defined yeah I would not depend on ordering here like I didn't even know that the Java the new the new JavaScript standard is that maps are ordered that sounds fairly recent there's at least somewhere in the spec away to retrieve the keys in some in in the defined order maybe that's not even the standard but it's possible now.

Really if I'm not a mistake it even in a standard JavaScript object that when you also that you can pass through to all the properties that are in the object in the order they are stored yeah I think now it's I'm not sure if all iteration options have the standard order defined but but there is at least one way to be ensured by the Java JavaScript ECMAS standard that this is now in the correct order maybe all of them I just don't know anyway in JSON I think it's less defined and so we should certainly not depend on JSON key order and yeah I would suggest to to keep it being lists for for pragmatic hackability reasons yeah yeah that's so good.

Great okay and good document we should probably document our reasoning there because this is a great candidate for the design decisions document isn't it okay it can be nice and can be nice and short red and ADR for that. So now while I wrote down the spec I I stumbled upon some issues that we hadn't thought through so right so well so maybe we can sort of together look at the stack and see what came out of it.

Looking for the screen share option I think I'm not oh yeah I'll not love by default yeah I gotta enable it I know I have it that's a great new green chair button just found it so this is okay now I don't get zoom it's weird why I got again why do I get this very very small just because I'm screen sharing I have multiple monitors okay yeah so here you see a very nice CSS hack yeah but it could look nice I know that's that orange bar was also in the front of the whole document yeah I would certainly not not the intention okay so what do we have this is all non-controversial yeah these issues should notes adjacent in area map this is what we just decided these should all be areas and we can also say why this is all non-controversial.

This is fine no issues okay so we have notes and they have these default properties then we have the first extension so the ports as an example I turned into a note extension which is I think what we discussed a while ago so this is how that looks in Jason so you in the note you have the data array that's where we put all the extensions formerly known as properties then we add the type and this extension has a ports array as defined here in the ports extension.

So every extension is described by a name which is just a convention I mean every local and this could use its own name but the URI is the mandatory name and then it describes the properties it uses in X extension in its extension and here we see an example of the extension being used this is simple and understandable and every extension author should sort of produce this snippet to explain what's actually happening in the extension.

Then as another example I also brought down the relative constraints extension this is now just yeah a suggestion from my side we never discussed it so far but as an example you could say you have a port that somehow placed relative a node placed relative to another node so you say the source node to which I refer and then I have a local position at rotation but actually my numbers are added as a delta to the position of the other node and that's it so for position and rotation I am is to describe how rotation works.

Okay yeah I like this that's where you'd want to use relative constraints and like would you does that mean that you would not specify the position is in position required at the top level already yes of course but if your app understands this extension it knows that this other node is always placed 0.5 next to the A node so if the A node is going to be moved and the other app does understand it could like move the B node next to the A node because that's what the relative constraints extension wants to express that's interesting I would have I would have expected that to be expressed with like a set of a group like a relation a group relation yeah that would also be possible and what always to express it right like you know they don't all have to be the same so no and we should we should reconsider this and maybe your ID is good and we should actually change it but let's leave it for a moment because relations which we come to next are slightly harder to understand okay all right.

So we have a relation and relations are really simple because a relation has this basic properties only some kind of ID just like nodes have they have a type which is actually a schema name or schema your eyes and we have the data array because a relation can have extensions on its own like visual nodes can also have extensions so if we have a set relation we have a type a set relation has a member has the member property which is of type ID array so this is how you use a member relation which is very nice and clean yeah and then you can have an edge relation which is from it too and I also gave it a Boolean directed or not and you can have a rel type this is to model the RDF relation type so it goes from this subject to this object and that's the property of the triple you can optionally put it right there in the edge if you need it you can also write relation is work add and just use a string that depends on your app at use case so this is still gentle.

Then you can have hyper edges and then I went a little bit over the top and just modeled every possible hyper edge you can have because I know exactly what to put there so the hyper edge also has a relation type like just like normal edge but it has more end points the end points here actually are an array you can have a number of end points in your hyper edge each end point is its own object has its own target ID to widget links like an edge has a from a to but this hyper edge has many more end points not just from it too but maybe 17 end points or three end points we don't know each end point has a direction so it's some edges a little bit like a block between the nodes and some nodes flow into the edge some flow out of the edge and some are undirected in relation to the edge that allows you to model directed hyper edges undirected hyper edges and even all these mixed weird cases okay you can also have that.

Then then you have weights you can have a weight for the whole edge which is quite common you can have a weight for each end point which is rarely useful but I have some cases you do edge bundling it like your model flows and two and two flow together and then the edge has a weight of four and then it splits into four and each of them has a weight of one then if you render that aesthetically it looks really good if you know exactly how much flow you have at which end point so the weights could be helpful this is like we probably won't need more edge types given edge and hyper edge so this is nice and it's still almost compact yeah.

So then we have the group relation what we discussed so a group is like a set and has members it has a bit more semantics defines for example we explicitly say that groups can contain other groups when a group is deleted all members are deleted when a group is ungrouped the group is deleted but the remembers members remain and I think this is a section of the spec that has to grow in length and precision for the other parts too because this is really the meat I mean when should I use a group in my app I'm doing this and this is better group by OCWG or not and then you have to look up the semantics and then you understand yeah that's exactly how it should behave in other apps.

I'm using a group maybe have parent child which is I think what Jin is is that we need for inheritance so we have a parent and a child link and we can say inherent is true or false it's like semantics of inheritance are defined by the application this is a bit vague by the moment but we can yeah tighten it if we learn more what to put there maybe remind me remind me what Jin's use case was for inheritance he had a good example from a 3D model like for transforms you say you you have some notes you group them and then at the top you add some group note and then you say you have a rotation and then all the other notes underneath should inherit that rotation angle and you only define it once and they all rotate which is different each member rotates then not the whole group as as a whole so it right oh you define a background at the top and all the members should get that background in its content so it's property inherent it's a bit like like in CSS or yep and you're defining a rule that you can then inherit around the different place yeah yeah interesting because those are those are typically what we would think of as node properties data on the node and we're using a relation to express that inheritance an inheritance of node properties I don't know that feels yeah this yeah this yeah so you have a template node and the other ones apply the template so I think that's a good candidate for relation actually.

Then we have actually I'm not even sure that this is the most recent version does it yeah I remember so there we have assets these are I think less problematic we know with resource and schemas and they are similar get different for assets we have for resources we can put them in an external and remote we define location my type content this was oh easy which wiki are the data in your eyes because if you have a data in your eye they implicitly already defined my type and the content so yeah so so if the user also stated my type that should be ignored because it's already defined in the URI and actually define it in overwrites here it doesn't make much sense then we have the fallbacks defined.

We can you go back to that example real quick do remote in order for a remote data URI to be valid does it have to have a mime type data your eyes always have a mime type yeah otherwise they have not data your eyes okay gotcha yeah cool so in that case if you if you were to specify the mime type oh I see you're saying in this case it's binary and inline content is that as the remote did okay I got it I understand now okay cool yeah then schema yeah we probably need some kind of tooling for validation but this is not really an issue in the scheme in the spec per se but rather yeah I mean that's that's reasonable like you're saying okay so a schema is defined as that table right underneath that each injury each entry is an object with the following properties a URI a schema object adjacent schema inline as adjacent object got it and then the location in the name yeah and then it depends a bit what you define what's required so you can have an inline schema then you're you always need a URI and if you have an inline schema you need to actually state the schema otherwise we don't know what the schema is mm-hmm if you have an external schema mm-hmm which is rather a little local file then you need to give that path so that we can find it mm-hmm and if you use a remote schema and the the URI actually does resolve to the schema and we can find it there that's cool and in any case you can give the schema a name if you want and if you gave it a name then in the other parts you can refer by name and don't have to stay at the URI so this is just nicer and shorter than the long form got it got it and the name to the name is the key to the map right here and you're here yep yep exactly yep which actually makes it quite funny because how can a name be optional not there so that doesn't work I was just gonna say like and how do you specify it yeah okay so so now we have two options required then or we turn it into an array which we're using for using elsewhere.

We we would end up with the concatenation problem again here right well the schema array is super short and yeah I mean it's the same problem you mentioned I mean it has like that happened it's a kind of consistency to use just arrays everywhere yeah yeah so it's I kind of feel like consistency wins out here a little bit over the readability all right so I took a note to change it to arrays and that also makes the name truly optional like you can if you want to you can leave the names out you can spell out the full URIs of each one of them actually you don't even need that entry if you just use the URIs to document if you use the URIs to what if you yeah if you use your eyes to reference an extension and not the name then why do you need an entry here if you have a resolvable URI yeah you can define it here but you don't have to you can just leave it out right use the URL did you mention that up above that that's like a shorthand you don't need a schema entry if you would like to use a fully qualified URI for a non-inline for an external remote schema not clear enough yet seems like a reasonable thing.

I think our preference though is that these schemas would be self-contained right that's kind of one of the sort of local first values or at least my preference it would be that you would actually include the schema in the file itself it has point cons so that would would say that every exported ok files everywhere contains all schemas which is just the schema so much I mean just the schema what just the schemas it needs for that file just the schemas and nodes and relations that are defined in it if I put the value I mean the value is you can open it while offline you don't need a schema to open a file true the schemas it's just adding extra validation actually the URI is the key and you either understand the URI and know how to handle it or you don't.

But I'm imagining myself as a infinite Canvas tools author and my thinking is that I would load the schemas and load the JSON schemas in order to build dynamically build objects that I could then load the so that I would want to do that validation myself as I'm loading in the OCWG file or the ocif file but for reading Jason you wouldn't need the schemas no I understand the schemas are just constraining the space often yeah they're just constraining the space of legal chasing structures yeah and that's what I was saying as an author I would want to do ideally I would say give me the JSON schemas so that I can put these objects together and then as I'm loading the file I can catch any validation errors as I'm loading it but if you don't understand that part of the JSON tree let's say that's the ports extension and you don't know what the ports extension is you don't gain anything by saying some of the ports arrays are valid some are not but I don't know what ports arrays do at all so what do you have a really important point I think there should be a description field for extensions so bear with me right yeah something like that I'm like free text where you can say what the disc the extension does for a couple of reasons one for human authors of like is this how does this extension relate to those you know the canvas at all and that could be so you know you could describe how this you expect this extension to be used but the other reason I'm thinking is for like LLMs that would consume this file format they could actually learn about each one of the extensions by reading the description yeah maybe so let's let's park that one too we are almost done and then we need to talk more about extensions so we have we could add some built-in schema mappings to to say these are always just built in and and yeah here we come to one interesting point so we have no extensions nice we have relation types nice they have schemas and then we have of course relation type extensions so these are let's say I haven't we had to set and now I have an extension to the set relation type then we have the set of course it has a version all our schemas have a version so we have a set version 2 with an extension version 5 maybe and version 5 of that extension applies of course only to the set extension version 2 and then if a set extension version 3 appears then the extension also is to this set relation types need to reconsider whether their extensions still apply and port them and so on and this is what if we what if we flattened it here and said that extensions don't apply to relation types they apply to like every relation type is an extension of the base relation just like every node extension is an extension of the base node type that way all the ones you defined aren't relation types they're just extensions then a relational type in at the same time be a set an edge a hyper-edge approach I believe yeah and that is really tough to interpret this is true but I mean that same I could make the same argument for a node that at the same time be a rectangle an arrow a circle a like you could just stack extensions on top of a node and make just as much gobbledygook of your file as you could with a relation yeah that's true and flattening it and turning every relation into an extension of a base relation just simplifies that base here I like that cool yeah and it makes it nice and parallel it makes relations even more parallel with nodes exactly and this is one thing that really I didn't like father I turned out well I'm glad I mean I think you put your finger on the problem now this is just a possible solution you're right it is it is awkward that possible solution I'm trying to think of it boxes us out of anything in particular I don't think so but I think what I think what you were trying to capture was also valuable which was there are these relation types that are kind of default or included or it's like the default set of extensions and these are the ones that are defined in the spec and so they don't feel like extensions they feel like first-class extensions or first-party extensions you know what I mean and I feel like we have the same thing that we haven't really done yet with the nodes where we're like these are gonna be the ones that OCWG is gonna kind of ship with but we're still treating them as extensions no differently than the rest of them yeah yeah if we thank you I appreciate what you've done of going going further to spelling all of them out because we need to do that on the node side and haven't yet so if we say we have a set extension and that's it then it's not possible to attach custom data to sets we say we have in order to do in order to do that you need to define your own set and there's no hint that your set has anything to do with my set ah no it's still in the same relation it has just two extensions the set extension and the other one that's actually fine that works that's like multiple inheritance yeah it's like we talked about with arrows we talked about this with arrows too there's gonna be a zero and a teal draw arrow I like that so technically one other thing was slightly interesting if we have a relation let's go back to an example where we use a really an extension yeah for example here here we have normal JSON object it has a type key a value for that key it has a type and endpoint key and a value for that key and you can put any keys you like set the type key it belongs to us that's the magic key and for a magic key it has a surprisingly common name so if you want to call anything a type don't call it underscore type or call it I don't know find another word type belongs to the reserved type yeah but is it still a reserved word now like I thought yeah yeah of course all our extensions are of this same shape they have a type and then they have other properties that's how we put them yeah so can you show me a node extension as well just to jog my memory yeah I guess I could look on the file on my side too actually so here we have a note with an extension it has the ports extension active on it and of course it has a data array and in the area you have the extension objects and each of them has magic type yep and that's just a reserved keyword and yeah I don't know what you're saying the type might be too simple of a name for such a magic word maybe we could also call it OCW you ochis or ochis type or or or ext type or or ext type yeah because that's what it is it's the type of the extension so it could be like that it's already a nice improvement ext type I could do have an opinion on this aesthetic idea I like typing the most actually yeah yeah because it's it's yeah because it is nice and simple one word I'm and Bill one either way the ext type or type feel good to me ext only adds three characters so but we can we can stick what type for the for the point being and see what others say we're just three now so I just want to bring up that this is the only magic key in that set and it's the only kind of conflict where we do have that mm-hmm and don't don't know it's themselves need a type no we just discussed how we unify actually notes and relations so notes have no type but they have extensions with a type and relations will also lose their type and just have extensions with a type and that way yeah yeah yeah yeah relations have multiple types if they need to right so type is not right but something is a node because it is in the node array it's implied is a relation because it is in the relation array therefore we don't need to add a type field to it yeah just nice that's good I like it.

We have not defined what a relation without a type actually is I was gonna bring that up you know it's it's just there and empty like a I don't know why not you can have it it's like a reserved ID yeah yep we have the base node type which does have stuff on it I mean it's gonna have an ID and it's gonna have a data and that's it yeah it's a data is optional already so right it is optional but it will have an ID type will be removed and delegated into data and then it just it's just an ID it's fine yeah yeah yeah yeah it's we simplified I liked it yeah then we just have like a concluding list of the sort of types we use internally which are more precise than the JSON type so we we have angles for rotation what do we mean by an angle are they in radians or in degrees so that's defined what's an ID in our spec what other IDs does it need to be unique what is a mount type and I looked it up actually it has to be called my type of content type content type is just an HTTP but my type is the generic yeah then maybe do an IANA registration one day okay yeah.

So the list of of open issues is really quite short so this is how this schema built-in stuff would look like right now mm-hmm and this will be a reformer to an array and as an example we have the extension yeah now it's I think a good time to talk more about extensions so right now we only talk about the schema of an extension and here in the spec already say a good extension is described by its your eye by a short name by a table describing the properties by explaining the semantics of the properties like maybe giving examples at none of this can be found in the schema so we have no agreed upon way how schemas are published documented how extensions are documented so we could have like a convention you should have an a document that has this structure this points it should be named this way it should be put there in your github repo and that's the usual way to find the documentation for the extension that will be nice and then we should follow that guide ourselves and maybe remove our relation types from this spec and put them in the extension folders makes sense yeah.

I'm happy to help I'm happy to help write node extensions as well this is something I thought a fair amount about when when Orion and I started working on the spec is like what are the base nodes that are being used across canvases so yeah once we have a format I can start I can knock out a few of those yeah there's a sort of the first proposal for most well great so I think what we're saying is that there's like a a github repo or a file a folder yeah you're probably need yeah if we web this to HTTP you probably need a folder and two files the JSON schema and the documentation file yep exactly I was gonna say the same probably a readme.md file is our recommendation but it could be something else if you want the nice thing about readme.md is that it reads well and github if you're browsing yeah yeah so we should use it to our advantage yep so I think it's a readme.md it looks like it has what you've got right here of an H1 you know of a the name of the extension you know some common name of the extension and then yeah schema the name the property the schema links to the schema file itself which is a JSON schema valid JSON schema schema file then a table that like you know shows the properties this goes back to my thing about a description field yeah so this would be much more powerful than a mere description field in the file so I agree it's more powerful it's not as easily queryable whereas if it's a description key when you pull down the JSON schema you get that description field along with it I'm not I'm not saying that that's better I'm just saying that it comes along with the schema itself I do think it's better for machines like LLMs of like you can hand them the schema and you don't have to hand them a separate readme.md yeah but honestly for LLMs breaking up the spec into multiple files would be a bad idea for a machine having it all in one document would be much easier to handle.

I think we should probably have like some tooling that does that basically that like like this is why I was saying I like I want those inline schemas personally like I think it makes like I want to be I want a tool that flattens it all into an inline schema so that I have it all in one place in a single file it's like it's there's a TL draw has like an example of this I believe where they have a they have a JSON version .json version that just has the data structure and then they have a .tl draw file I'm gonna go check my like exacts here but they have two different files one of them just has the data and one of them has the data plus the schemas fully fleshed out and then the advantage of the data plus the schemas is you can have the exact version of the schemas in in that file that were used at that time or you know used to create that data and you can you know kind of package it all up as a single file that can be opened offline by the TL draw JavaScript viewer without having to connect to any schema servers or anything if those schema servers aren't available the schema versions aren't available it's like doesn't matter like it's all not one self-contained file and I've made the mistake before getting the JSON file of a TL draw and not having the .tl draw file so I didn't have and I wasn't able to do a few things that I needed to do and and it was actually around validation I had a weird validation problem with my JSON file but I didn't have the schemas available in order to do the validation so I had to go back through their repo and like manually pull them down it was kind of a anyway that long long story but this is why I think having a scheme is hydrated in a file can be really useful so what we then have two flavors of ocif the ocif pure and the ocif hacker version of a file ok what's the difference between two pure is just the data and schemas are just linked well and heckers the hacker friendly version where the schemas are all in mind I think I think both of them are valid ocif files the way you've defined it right like one of them has external URIs for the schemas I mean but should we like what I mean if we write a spec we should tell the application offer what should you put in is it common practice to always put everything in or should you offer two export options or what yeah it should be done I mean it's it's on to ask right right the way if I were writing that section and this is just me and I mentioned this already the way that I would write that section is I would say our recommendation is that you and you bundle the schemas with the file for the sake of having a complete file that can be opened offline that can allow maximum flexibility for an infinite canvas authors to be able to do that full validation without having to hit a remote URI all that that's the recommendation but if you want to save space like if you want a smaller file format you can omit the schemas and pull them down from an external URI or package them up as an you know an inline or a file alongside that they can you know like a local URI if you wish and that could be that maybe that's the ocif bundle that I was just referring to like the teal draw bundle that has because you could actually have the data and the schemas separately you know and resources you can there could be some kind of ocif bundle but yeah that that was that's the way I would write that section is recommendation is in all in one place yeah okay that's fine and I think we can offer like a command line utility that takes a an ocif file in any format and then hydrates hydrates it and you could do the same thing with external resources as well by the way which would be yeah like turn them all in local data URLs and so you know you know if it's like five or ten megabyte ocif file because it's got all the local resources in it but hey it's got all of them right like that's yeah for the spec if we put the description of the extensions in separate files then the spec itself would be harder to read and less rate for LLMs because the energy multiple files is not so nice for LLMs so there we would also need some kind of bundler to create like the long version we could do the silly like a very simple version of that which is basically just concatenating markdown files so we could we could specify our bundler could basically be you know here's the full spec in the node section an array of OCWG nodes types that we say are kind of the default and we just literally iterate over those grabbing those our readme.md's and then so we can make we can I mean I think I could write that bundler for us if we follow this readme.md format right where the the readme can be just literally embed like concatenating inside the file but this is how the readme.md should be formatted so that this concatenation actually does work I mean but that will be but ok you also need some heading in that adjustment and headline one becomes headline two something like that yep that is true I was thinking the same thing it does work an ASCII dog I think you're gonna have a hard time selling that one Max I know you like ASCII doc but I think for critic reasons it would make sense to leave the bundler default extensions just in the main spec and maybe as an example say oh that would look like readme.md yeah I think that's pragmatically that's I think that's entirely reasonable to make it one easy readable doc we can even we can even link to the we can have a link inside that from the main spec to each child you know node extension and sorry to each node extension and relative relation extension that links to that folder where the readme is and that kind of thing and yeah but it's super cumbersome to maintain so for the built-in things we would in the readme say actually this particular built-in extension isn't documented here like it should see the main spec that would be very pragmatic and then we have one example extension where we say here you actually see as a template how that should look like ok and that's it but minimizes maintenance I like it sounds good.

So then the the as we iterate on the versions of the not the high-level version of the the OCWG spec but as we iterate on the versions of the extensions we will have to make sure to update the main spec yeah we have either way so we need to decide hard which are really built-in types except in extensions and which are not yeah I think that's a great topic for next meeting of like let's let's go through our list of I think you've already done it basically for relations now we need to do it for nodes yeah and maybe maybe your last thing is yeah what do you think now about the relative constraints I mean obviously yeah it could be a relation it could also be a node extension it's very I don't know it's not very structural or semantics it's addressing the visual properties like position and rotation of one node relating these visual properties to the other node so I don't know it felt closer to the visual domain so it's a visual node extension but I think it's also a node extension I'm not yeah I think it could be implemented either way you could you could implement it either way as a group extension with where the group or set with either one a group or set has like a relative property on it so you could call it a relative set or something along those lines now the that would make it more powerful maybe that feels so that the difference I guess is that yeah that would make it more powerful because then you could have wait because this extension it doesn't have an array of no it's you put it on one node and say this node is actually positioned relative to another node node and my relative delta is position of that node plus this and the rotation plus that okay so I would I would define I think it's better as a relative set because in the relative set you can basically specify an array of all of the nodes that are relative to the source node but you need not only to state the IDs of the relative nodes you also need to say what's the offset so you need an area of the same length for all the offsets oh yeah you're right okay then you make sure that the arrays have the same length and yeah that is that is kind of dirty yeah