
Awesome. Alright, welcome to OCWG meeting number 25. 25. We're a quarter of the way to triple digits. Yes, so things I wanted to talk about today, 1.0 release candidate/candidate recommendation, I guess, is what it's called. And the other thing is talking about -- I'd like to talk about my talk at local first-conf and kind of share what I'm thinking about showing off your feedback and kind of -- yeah, I think those are the two main ones. But I noticed we had some other stuff that was brought up. Sounds like Max and Michael, you guys talked about some stuff last time. Yeah, what do you guys want to talk about?

Also, Aaron said PR.

Oh, yes, that's right. I was going to say there was a PR out there. That's right. We should talk about buffers.

Yeah. So, in the last meetup we had, we discovered that we are still a bit weak on nested canvases. At least it's not clearly stated. So right now we have two ways. One is to explicitly include a resource, which is an okif file, which probably should work somehow because it's all specked, but it's not clearly defined how exactly the coordinate systems play together or how that works. Or one could use the extension by Michael, which is maybe not needed or maybe is needed. And while we are at that, I discovered that we have this nice scale property in our nodes. And in my mind it's not completely clear what exactly this scale property is supposed to do, which is also related to nested coordinate systems, I guess. I think Aaron is someone who can educate us on this.

So we have already this. So right now all positions are global positions. That's why having floating point numbers is quite crucial. Otherwise you couldn't express much. But even with floating point numbers at a certain zoom limit, you hit limits of floating points, at least floating points on a machine. I mean, Jason allows arbitrary precision floating point numbers, but CPUs don't. So we should work with the assumption that there are some kind of floats. Doubles are like, I stated that it's usually doubles the vast majority and that's like, that's like the best case scenario. In practice, a lot of places will import that as 32 bit floats. And that's, that's even worse.

Yeah, even doubles don't really solve it. So a colleague of mine working on this infinite zooming canvas, infinity maps, he also states that that for an implementation you need something like scale factors. And we have them already there just under documented. So maybe you could start with a scale factor. I think you brought it up and we just typed in your we have scale factors now, but I exactly are scarce factors supposed to work right now. Maybe we can extend from there. So if a node has a scale factor of let's say 10, 10, what is supposed to happen?

Before we jump into that topic, do you guys mind if we like rank order these? I'm worried we're going to run out of time.

Okay, what else do we have? Yeah, here's, here's what I've got on the screen. So we've got offers, candidate recommendation, local first comp talk, nested canvases. And okay, so just suggest to swap a four and five, because nested canvas is more based on scale factors somehow, maybe.

Okay, got to solving scale properties might help. Max also mentioned the like coordinate system with the global coordinates and such and maybe that was included was not to be included in the scale property discussion.

Yeah, yeah, we that's fine. Yeah, or maybe it was intended to be included in the nested canvas. I don't know what it's related to that.

Yeah, but we have global coordinates. I think there's no real discussion on that.

Okay, I see.

Yeah, yeah. So the thing about global coordinates is all coordinates are relative to something. So when I hear when I see like in the spec global coordinates, the only way that I can really interpret that as an implementer is that these coordinates are relative to the root of the document, right? So if you were to select your your imported oak if document and move it, that should move everything in it, you shouldn't leave behind all the nodes, you know, that would be really weird. So I expect that it's always relative to the root of the document.

But that means our document has no explicitly defined root. So we should state that the implicit document root is at zero zero or?

Well, that yeah, that's that's it's a plus it, I guess.

Yeah, it's it's every will every every coordinate system is relative to the zero or vector, right?

Yeah, yeah, that's like what it means to be a vector. Origin, that doesn't need to be.

Yeah, we say we state like that the origin is the top left corner of the canvas, which helps people know that, you know, it increased, it gets positive moving to the right and moving down. But the fact that there is an origin at zero is kind of implicit in every coordinate system ever.

Yeah. So now it gets interesting if we add skate, but yes, you wanted to go in another order through the discussion. I would prefer to.

Yeah, if you guys don't mind.

Yeah, I'd prefer to get to that one later. I know that like it's juicy and it's right there. And we were all just thinking about it.

So let's start at the top.

Whoa, what what happened? We lost some content. That was strange.

It looks good.

Okay, that's CL draw calm fail.

Yeah, I had started.

Okay, so yes, let's timebox this discussion to like 20 minutes buffers and archive bundles. So we don't because I think it's possible we could spend the whole time on this one as well. Maybe 30 minutes, we'll see. But I do want to make sure we talk about candidate recommendation. Actually, do you guys mind if we talk about if we move bump buffers down to below the candidate recommendation and local buffers as much as you want?

I mean, no rush.

Okay, because they're so there is some timing stuff with local first comp talks. So March 28, May 28, in Berlin, at local first comp, there is going I have a talk spot that I said I was going to talk about application interrupt and file formats. I don't have a talk title yet. So I can kind of change the title around however I want. But I have a full 25 minutes to talk about whatever I would like to talk about. And here's what I have for an outline so far. I was sharing this at the beginning of the meeting.

What I'd like to do, oh, I guess one other piece of history that's kind of interesting is at local first comp last year is where we wrote the first version of like the first documentation, the first version of the spec, like version 0.1 was Brian Reed and I sitting at a table outside of local first comp and saying like this can't be that hard, how can it how are it going to speed like we need one of these and we had been I think we'd been chatting slightly before that on Twitter about it. So we knew we wanted to work on it and we knew we were going to both be at a conference. So we sat down and like wrote the first version there.

So it'd be kind of fun at local first comp one year later to say, you know, here's a picture of Orion and I writing last year like 0.1 and today's like the 1.0, we're announcing the 1.0 candidate recommendation. It'd be kind of fun. But the goal of the talk is to talk about application interrupt. You guys might be familiar with local first software, you might not, but the idea is, you know, that the when applications are running on your local machine, you do have the data on your local device, but you don't always have the data in a way that it actually makes sense to access it. So it could be that is usually because they're stored in I can't help you right now.

So that might be because yeah, yeah, a lot of times that's just like if it's a local first app that's in the browser, it's stored in some esoteric database that's locked inside the browser, like the user can't get to the data in any way that's meaningful. And so the the encouragement here is for local first app developers, at least offer exports to flat file formats. Like that's like level one is the let people get the data out of your application in some file format that's not your fancy little JSON file or binary. God forbid, a buffer, for example, kidding.

But yeah, so then so we'll talk about markdown. I'll talk about some different things that export enables. So you know, you can use markdown. There's like these really fun dialects of markdown for using them for like calendars and to do systems. I'm going to show a little demo of my that I built of turning up for a tool that I use that turns a markdown to do list into a Kanban board. And you can edit it both ways. Like you can drag the cards around and it updates their status. And that's enabled because of city and like rights to the file.

And then I was going to make the comments of like, you know, look for existing file formats that you can support rather than like coming up with an arbitrary one yourself. But sometimes one doesn't exist. And you have to come up with one yourself. And so that would be the intro to like OCWG. I guess what we know a thing called OCWG. And I'll talk a little bit about that. I don't know what the fun like maybe the most basic demo is showing like a super basic OCWG file and showing that like opened in three different things. Maybe like maybe showing an SVG export, maybe showing it in an SVG showing it in a city in canvas showing it in teal draw or something. I don't know.

But I need some demo to like introduce to motivate OCWG. And then the next thing would be the next level up from just like manual export is continuous export. It's read only, but at least you're always projecting your internal file format into some file that people can write readers on top of to represent that file in some different ways. So one good example of this that's kind of cool is linear. You can link linear to a Google sheet and it will automatically keep that Google sheet up to date with all of the issues and all of their status and all of their columns and all that kind of stuff in your linear instance. So it's read only. If you like make a change in the Google sheet, then like linear on the next right will like overwrite that change. But you can build cool stuff on top of Google sheets like you can build your own charts. You could build your own like dashboards on top of that sheet that refer to cells in that sheet.

Go ahead, Max.

That's not local. Google sheets is not a local thing. Would be nice to have an example with a local export. If you have one, I'd love to hear it. I think linear is local first, which is cool. But I agree that would be it'd be nice to have another one. I have I have an example that might qualify as this in giddo engine. So giddo can import GLTF files, but users don't always have GLTF files. Sometimes they have blender files and they have to like go through an extra step to export it as a GLTF every time they make a change. So to make that workflow easier, giddo has integration for blender where giddo will just detect when a blender file changes and then literally you give it the path to the blender executable, it will run blender, export it for you, then it will save that that GLTF and it will import that GLTF and it will pretend that that is the fun file.

Wow, that's robust.

That's pretty nice.

Yeah, that's exactly what you want.

I mean, for my opinion, we could basically use oak if like demos the rest of the way through. It's kind of like after after introducing it, like it doesn't have to be linear to Google Sheets. So another example could be, you know, having TL draw continuously export a an oak if file, which we then like rendered to SVG or something else. I don't know. I'll have to think more about like what are some cool demos and cool things we could do with oak if. But that's like the next level is continuously export. Then the really cool one is like full source of truth, like read, write, where, you know, if we had an oak if file is sitting on. So this one, I was hoping to maybe use obsidian canvas and like maybe a local running version of TL draw. And so it's watching via the file system API that local oak if file and also updating that local local file.

Obviously, if you write in both places at the same time problems, but it would be cool to like show obsidian canvas on one side, editing it on TL draw on the other and then go to city and camps on the other side and updates in TL draw. Open to using other tools here doesn't have to be these two. It's just I know that city and canvas already supports file reader rights. So I don't have to implement anything there. We just have to do the obsidian. We have to have some like watcher that's watching the file, the oak if file, and then continually writing out the Jason canvas file so that obsidian canvas can pick it up. How I'll do local TL draw, I'm not exactly sure. You guys have thoughts on this one?

I think it's doable. Local tortilla should be a big problem. I think you can use the package.

I think so.

Yeah. I think it's the thing should be pretty easy.

All right. And then the final thing I thought would be kind of cool is talking about the other benefit of robust file formats is you can actually ask AI to write out those file formats and AI, if you have a well-defined spec, then AI actually does a reasonably good job of actually writing things. So I was thinking about maybe even having like a model context protocol tool that can write oak if. And so then I could show it inside of a chat with like Claude or something like that where you're doing some chat and you're saying, hey, can you write out a couple of and it like writes out these oak if files for you and then you can open them up.

Again, I'll have to work on making the thing cool. But just giving, oh, I had another thought about this, by the way, over the weekend of it would be really cool to have a benchmark for AI's ability to generate canvases. So you may have seen a couple of people like ask AI's anytime anyway, I comes out, they ask it to generate an SVG. Like there's one guy that does an SVG of a penguin writing a bicycle. I think that's Simon Willison. Every single time, generate me an SVG of a penguin writing about that's like his benchmark. It's not a robust benchmark, but every single time he's seen it like get better. I wonder if we could do the same thing to like basically, yeah, to promote, there'd be, this is like a side project. It's sort of Oakiff or OCWG related, but having a benchmark that's like how well, and we could basically have gold standards of given this prompt, here's what you should be able to generate. And then we could do some form of scoring of like how close has it gotten to that particular bench. Anyway, that was another random thought, but I think the final demo would be AI and writing Oakiff.

So we have a basic Oakiff generator with AI already.

Yeah, I was trying to figure out how I could get someone else to build all of my demos. And then I just have to worry about giving the talk.

I just have to make slides and Michael will make an awesome demo of AI writing Oakiff and Max will do another demo and Aaron will do another one and I'll just make awesome slides and get up there and talk.

You make them manually without AI? Jess, what's happening?

I don't believe that. All right, so I think the big takeaway here is what do we want to do for a candidate recommendation assuming that May 28 is our target date for announcing that candidate recommendation. So I think that would lead to my next discussion point. Anybody have thoughts or ideas on that?

Yeah, so I looked up the W3C process on that and they basically write up a spec, let it simmer for a while, then invite people to give feedback, then improve the spec and then say now it's a candidate recommendation, we solved all open to dues, everything seems to be clear to us now and now we invite people not to give feedback on the text but actually try to use it. That's candidate recommendation status. People please implement it now, it seems ready. We could say we are almost at that step and then maybe look at all open issues and to dues to verify that things are looking good.

Today I asked Gemini to give me feedback on the spec and look for inconsistencies. It found only minor things, that's fine and I added them in the PR already. So overall the spec text seems to be rather good.

Yeah, maybe the biggest open issue in my mind is this using coordinate system to make that more precise and deal with the nesting than it turned. Do you guys see other unclear parts about the spec? Do you have something you know about right now?

I don't personally, I mean we probably should talk about buffers because that would be a big I think in general having an idea of how we're going to handle archiving because that was the topic that Aaron's post brought up for me of like oh yeah we probably should at least have an opinion on how you bundle together assets that are not like linear that are not embedded in the file itself.

Yeah and it could always be like done as an extension too especially if it's not super common to need this for canvas apps. On this note I want to mention that it is really important to have plenty of like test assets and actual like compliance testing done to make sure that implementations are following things and to be precise enough where it's like impossible for anybody to get things wrong because there have been many cases of standards doing things wrong and then like it's like a huge mess trying to clean it up because right some tools are exporting things for compatibility with this thing that does it wrong so then the export is doing it wrong and then you try to like submit a PR to the export to fix it and it's like no we're already doing it this way for this thing and it will break will break compatibility with that thing.

This was a big problem with the KHR lights extension for GLTF the light unit was not being respected properly because of a bunch of confusion so like the spec said it was lumens or candela depending on the type of light and the example file shipped with lights that had like an intensity of like one and ten but like with lumens you're not going to be able to see that it's too dim you need like 10,000 lumens to be able to see anything not 10 and blender was exporting lots so that's also completely different so we had the spec and the examples and the blender implementation which by the way was maintained it is maintained by cronos these three things that were all made made by cronos completely different and they did not work with each other at all.

Yeah no I that was that was what I was going to say as well um Aaron is I don't see any real significant open issues with the spec itself but I see a huge gap that you could drive a truck through in terms of tooling testing like verification and I would really want to at least provide like a TS library with some tests um and that kind of thing before we get to recommendation candidate recommendation now none of that work is sexy like it's just grunt work but I also think AI could probably do a bunch of that work for us um and so uh I actually have an open PR that we could look at um not in this meeting but we y'all could look at afterwards that basically lays out how the monorefo should be designed that the oak if tools thing of like how should we solve the library problem how should the CLI work um and then it like lays out an implementation plan and my my plan is to go through this with it with Gemini and have it like build each one of these phases um and the important thing is like having it be test driven at each stage like here's a bunch of examples um and have Gemini generate the examples and then like curate those um so curating more the test suite um is kind of my thinking on that but we'll definitely would would love support in that area as well um by the way just really quick with the lights thing um yeah this this is this is actually like years old but still hasn't been resolved yet because crotos hasn't corrected provided correct examples for us to go off I mean this is a I mean markdown is another example where uh there the spec was not fully fleshed out when john groover released it and there's all sorts of edge kc things in markdown that like don't exactly work um but I think variants and markdown is so frustrating and I hate how it's like some places use the underscore for like italics and some places use it for underline the underline makes sense but then like the original thing was was italics but yep just two ways to do unordered lists with the asterisk and the dash yep and also the spacing between lists you can have brought wide space lists and not wide space list and yeah not everybody implements either one of those weird um okay so anything else from terms of candidate recommendation like if we had for example a tool an oakif tools repo and that oakif tools repo had a library a ts library that you could use as sort of uh when you're parsing a uh an oakif file you could bring it into sort of memory and then have like well typed things um you could validate that file and then you could also export import and export to just a few formats like we don't need every format on the planet but like um a tl draw svge i'm sitting canvas maybe that's our our first three would that be sufficient in terms of tooling uh oh and and assume that there are tests of like there's you know 20 different 30 different oakif files maybe more that we can then uh ballot like a run of test suite against and then maybe a few examples of tl draw like like those the converters are tested as well i will note that automated tests are great but uh for a lot of these we're gonna need to like verify like visually that they're correct um you you are gonna have to have whoever's doing the implementation part of their job will be to like run this this gauntlets of test assets through it and take a look and like see if it matches it you need to have screenshots of every test asset too so that it is clear what it is supposed to look like we get potentially set up playwright infrastructure for that of like have it um do visual diffing between of like great you change this but now the visual diff is different um yeah that would be some significant infra uh setup i would say for candidate recommendation where we don't have to have all these exporters and importers and helper libraries already that's part of the candidate recommendation phase to build the tools to have a validator and tests yeah maybe that but other tools uh not to prerequisite for CR status good point okay so you would you would say had the their validation and validation examples and tests somehow automate running examples is probably enough yeah that's a great point um fair enough i would also say like there's some other logistic stuff that we'd want to do like uh other tasks um like update the website um update the website update the read me the org read me um yeah on the website i would i would propose that we somehow render the spec to html and also publish it on the website so that it's not in this little rectangle i agree even get up but you have only readable yeah and yeah i do think more examples like that's a that's a big one um it'd be great to have running examples um running in child draw export to csv live export sdg um something and then yeah some tests i like this as an ordered list though of like most important is to have a validator and some examples and then um tests and then yeah most you know somewhere down here on the end it is like tools for other things yeah this is a good order all right well i'll take on the work of it's already 12 30 got half the meeting and we probably should spend time on these open issues so i'll take on the work of like getting this into github as issues with like a milestone of a cr milestone and we can debate about what belongs in that milestone and kind of the priority order there um what do you want for the 28th what's that say again michael first and then yeah what what do you want uh uh what do we want before the may made the 28th of the public candidate recommendation because this is already very extensive list i think yeah tis um what was the question about may 28th though what do i what do i really want is that what you said yeah yeah like an m&b yeah probably the m&b would be um like the probably the m&b would be this it's like update the website with a rendered html spec with just what we have today and just be like there's a validator oakiff validator like website we don't have a library we don't set up oakiff tools we haven't set up we don't have a ton of examples yet but you can go read this back um that would be if if that's the only thing that happened i would still say it's worth it um this is just like sweetening the deal in my mind yeah maybe the other if i could get one more thing and probably be more like an example or two on the website like more examples is probably in my mind more important even than validation because there is a validation website um like you can you can do validation it's not the best to be able to have to do it there and not be able to do it from the cli or from the library but it can be done whereas i feel like examples are super important for people to understand how the spec actually works um and the validator can export to spg and tldro minimal but it can can export so agreed agreed yeah file over app was a major inspiration for uh what i was working on um oakiff generator yes the oakiff generator tool oh what i was gonna say a minute ago is that i know you have like a deadline of may 28th here but my own opinion is that something as important as a standard like this for a file format that should ideally you know exist for hundreds of years um should be you know carefully thought out with time and not rush or anything so if it were if it were me and i'm like just developing it myself i would spend like a really long time like developing my own implementations and like several things and a validator and i would do like a lot of development before i even like posted it anywhere for comment because i would want even if i had to like repeat a lot of that work i would want to you know make sure it's at a really good state before i present it to people so that like right after that it's pretty good and then um there's a less chance of something bad becoming a standard that plagues people for hundreds of years here um in fact i'm glad you mentioned the hundreds of years because the uh the local first comp the local first uh principle that i'll be talking about is the long now um that's like one of the seven principles of the the thing and it's one that is rarely talked about uh within the context of the local first community even though it's right there alongside the other six principles in the original article um is there anything that concerns you erin where you would say like now you can take say today that you would be uncomfortable with may 28th like and would recommend that we not do a candidate recommendation and we like what's the phase before cr max i'm trying to remember uh that was uh last call working draft working draft last call yeah i don't i don't know what what to call it i'm not a marketing person but i would just you know do a lot of development while it's in the draft phase and you know uh hopefully that means that like once you get it out of draft you can have a pretty seamless uh whether it's timely or not i don't know but like a pretty smooth transition into release yeah but candidate recommendation is not a release yet it's still a kind of draft but it's the the state of draft says now we are looking for implementation feedback not for text feedback so yeah i think i think this is the uh the five phases erin um and so we're not actually at it we wouldn't be at a proposed recommendation we would be at the point where the way we're going to get good feedback is not someone it's unlikely that it's going to be someone reading the text of the spec and going ah have you thought of x it's going to be them like trying to implement um and discovering like oh you guys missed this huge edge case um and so like like max pointed out which i really appreciate you pointing out developing the test suite to verify interoperability is what you do during the candidate recommendation phase and yeah that's a that's a fair point um and also take some work off my plate so thank you for saying that max or some pressure that i was applying to myself i guess i should um yeah so i think for me candidate recommendation is fitting all right that will make sense i do want to i'm not objecting to the candidate recommendation but i do want to raise one counterpoint uh against it um which is that when's the last time that we merged in a pull request that uh changed an existing part of the spec instead of adding onto it and the answer is today um so to me it doesn't feel too to stable yet like i mean this we could easily make a declaration like oh we're not going to change things major league for if we're pretty happy with it but you don't know that yeah it's true um but i think the i think the goal of the candidate recommendation stage from what i understand is actually to still be continually making changes to the spec but be making them based on implementation experience and so yeah the the expectation is that we won't be stopping making changes to the spec right now you should not treat this as a 1.0 you should go play with it and fiddle with it it's weird that um the w3c uses this language that it's like a 1.0 candidate recommendation but it really is like pre 1.0 the way that we think about it in other software versions um but yeah you're still openly iterating on it making changes to the spec on a daily basis potentially all the way up until you say like okay now it's a proposed recommendation and we're not actually um making changes yet um and we're gonna leave it open for you know several weeks or um so obviously we need to verbally explain what we mean with candidate recommendation because not everybody's familiar with w3c processes yeah great point max and i'll do that in the talk i'll heavily caveat um well actually funny how omi is up as a part of the w3c but we have like a completely different system at omi so i've never heard of this before it's you know it's a like everything at w3c it's a uh recommended process that you can follow if you would like it's like available to you here's a process that you can use but you don't have to then these these organizations are so big you know w3c kronos uh even didn't know that united nations has his own metaverse uh standards organization i i definitely did not know that um art right buffers archive bundles etc um let's spend a minute on that or unless or i guess let's choose we've got 20 minutes these are both probably 20 minute conversations like buffers like archive why not we have it listed above um so to recap we start with a JSON file and we only refer to external resources okay cool then we discover yeah okay sometimes that's not quite standalone so we want to embed resources so we take the easiest next step embed the resources as base 64 that solves already a bunch of problems we now have a single file if it's too large we can zip it and file add a certain size if you have not three images in it but 300 this becomes not nice to manage not nice to load in an app it doesn't really scale well so suddenly you need to find them next way so then we have these external references so we have the JSON file and next to it we have the image files which is super nice for a local app because you still have just a jpeg file locally you can double click it open it in your local browser everything works fine with local files just need to make sure that the local references resolve correctly but now you have a new problem now you have a bunch of files how do you ship all these bunch of files to a friend uh you need to somehow have an archive format that somehow defines what needs to be in that file where in that file and what exactly is the archive and then there may be two routes to take one is to say we define a native archive bundle which is very compact nice and everything which is one way or try to leverage something like a zip file like what Java does with jar files so to have a defined archive format based on zip archives where you basically define the path structure and where to find the archive file in that path structure and then the big problem with the zip files is they don't have nice random access so you can okayish read a single file from it you need to skip through find the right index and decompress that one file that works okay but if you really want to update one file in that zip bundle that's not so nice so if the app usually has everything in memory and then just the export is doing is done in the archive file that's fine if it's usually having some other database somehow for its final just using the export in the zip file that's also fine but if it's really the native format to zip file that's probably not a great choice but as we are export interchange file format designers maybe we don't have to aim for a native file format because most apps will need their own native file formats anyway so I guess some kind of zip archive could fulfill our needs unless I misunderstood some leads from Goro engine yeah that could certainly work and having everything stay as files in the zip does let you keep leveraging that the URI so yeah that that would make sense yeah I had not considered that before so I haven't like pondered about like entirely what are the upsides and downsides of that compared to just using doing it the way GLTF does but that is a good a good thought so then even in the spec we could just add a chapter saying okay if you want to bundle it up in a zip archive this is how we define the structure but everything else about their local file URLs and so on just stays as it is which I like and debugging is also nice a very often I took an zip unarchive utility opened a jar file looked into what classes are there and figure out what's wrong so it builds on existing tooling but I'm not sure how nice it is to to use zip files as native containers in the browser I don't know if there's a JS unzip utility not familiar with that for me I would just expect that you could just load the whole thing and then extract it and then like import it into whatever native format you're using which it might just be you know an extracted version of the data that's uncompressed of just reading the oak of data or it might be a completely different thing that is what your engine uses so the other consideration here is that buffers provide a more general solution for storing just kind of any binary blob of data so like one example use case is like a png image but there might be data you want a store that isn't like in a well-known file format so we could still do that in a zip by like pointing it to some file dot bin and the it's just unstructured data and you have no clue what's in there and a buffer would allow you to pack in multiple things into the same thing which is maybe not so important especially if you know it's a zip then to the to the user it's presented as a single file so you don't really even notice that it's multiple files so when I started working on this i was like i was working on this in the context of giddo and in g4 mf my working on like the gltf in giddo and then working on my own format which both like have this need and i thought you know what i should do the same thing for for ok if since i it's all a stretch in my mind but after like making the the PR like as i was writing a description i was thinking like hmm maybe it's actually not really needed because um you know with with a 3d model you have a lot of these a lot of these blobs of data it's like it's mostly going to be these blobs of data for describing like a mesh geometry and vertices and and stuff and with a canvas app you're mostly going to have geometric shapes and colors and images and those can either be represented as JSON data in text form or in the case of images just as a an existing format for the image so i think the use cases of of the buffer is much less it's certainly much less for canvas apps than it is for a 3d model to what extent i'm not entirely sure but um it would be an argument in favor of going to zip bundle route because that would be like i think a lower friction compared to the dominant use case of we're expecting here where most things do have a meaningful format in a separate file or just in text form cool so maybe we explore the zip route first i think so the other the other benefit that i thought we didn't that we didn't talk about is being able to export all of my files like do a live export from my file system to my file system in a file that's not in a folder sorry that's not zipped um then you can do things like you know copy the copying the image out the images out of of a uh of a canvas becomes this like file system level operation as opposed to like clicking around inside of an infinite canvas to like grab all of the pngs and jpgs and that kind of stuff that's kind of cool and like buffers explicitly don't enable that right because it's just that binary blob of data um but that last bit only works if we do specify your images should be placed in a folder called images right now we don't have anything like that we just have used URLs yeah i think what we could do with this bundle is is not specify it strongly but like uh but recommendation yeah here's a here's a recommended structure because we also don't know what kinds of files people might want to put on their infinite canvas that's one of the things about infinite canvases is you don't know all the file types um and some canvases support really weird wacky file types that you wouldn't think of um and you want to support that as a potential asset um and let them be okay with that so we can we can make recommendations but we can't say like here's where everything is going to be stored because we don't know where what everything is um you know seems like a reasonable thing to explore cool we may do that quickly should we talk about um so yeah like i guess the yeah uh about the next one i have updated my pr to be a draft so that um it's clear that it's not like uh something we want to merge any time soon gotcha yeah and are you interested in pursuing that as a an extension erin i'll let you consider that but like that would be one way to like morph your pr is like but if we if we only have a few buffers for geometries and stuff which are maybe not that large i'm not familiar with that then maybe base 64 is is just fast enough that's true and also like i expect that for any two-dimensional object in a canvas the data like that kind of data is going to be less than a 3d model anyway um yeah so i think the the another just the the single biggest benefit of the zip uh format i think is that it lets you can we can kind of implement this this zip format without like changing the ocaf spec at all because the ocaf spec it doesn't it we could just keep using file URIs it could the ocaf kyle could just think that it's doing file operations and like you could very trivially just extract the files and then just say go import this and then any implementation it doesn't support the zip based can still import those things if you just do one manual on zip so like it is very convenient and so what it what it really be like an ocaf extension it would be more like a format defined on top of ocaf the letter yeah just a part of the spec that says like oh hey you can do this and here's how oh yeah no i was actually suggesting i don't think this the zip bundle needs to be an extension but i was wondering if you wanted to explore buffers as an extension yeah i could for that i could easily move that to to an extension yeah um i am uh i do wonder uh what use cases we haven't in mind for it because if it is an extension and we're not like requiring it then we do want to like you know we we wouldn't use it for things that you could already use the base suspect for it because that would be you know silly so png images should still be as files or as base 64 for example um so i do want to we do need to think a little bit about like the what the use cases are for it to make sure that we design it in a way that's good for that and to be fair there's not really that many ways to design it so maybe i'm overthinking this but i i like to have use cases when i design things heck yeah well that makes sense all right you guys max and michael you guys talked about nested canvases last time we've been talking about scale properties and floating point precision um yeah where do you want to pick up yeah let's start with scale properties we have a note has a scale property right now and i'm not quite sure what it really means so we have a scale is a vector for all dimensions let's first start with 2d and let's say we have a scale factor of 10 10 so what what is not changed and as a user of a game engine the concept of scale is very like intuitive to me so um my my like immediate thought even though you mentioned this way earlier by beady thought is still what about this don't you understand like i i can't really get into the headspace of not understanding it yeah we have global positions so every node has a global position anyway so the scale factor is seems irrelevant no matter what i do there this node position stay the same unless i use relative nodes extension but relative nodes extension only specifies an offset to the position so if you if you keep a node in the same relative position and you scale then that's all that's going to scale that's just going to move the global position so but it'll change the position that gets serialized in the okf file uh but it doesn't just change the position it will also scale that node because if you scale a parent it also scales the children by that just kind of how the behavior works so but only if we also use parent child right scale without parent child is sort of meaningless yes yes well if you have scale without parent child then that only scales that single node because there's there's no hierarchy so it would just like if you had like an image resource displayed on that node it would just make the image 10 times wider and 10 times taller but also the node itself so the dimensions the node has a i think a node has a size so let's say the node says i'm 1 1 yeah and then it says scale 10 10 so that means it has size 10 10 yes that'll be the global size it it's it scales everything about itself so the scale affects itself not just its children itself yes so it will affect itself and any children if it has any children but that's only if you're using their relative the relative node or the parent child node extension i mean okay this as stated like you just did i don't like because it's different from what we have for the relative node extension the relative node extension does the following we have a node positioned here and we have a node positioned here both in global absolute coordinates relative to canvas root and then the relative node extension can say actually my coordinates are not random they have been computed by taking this parent node and adding an offset of 2020 to it and that's how i arrived once at my global coordinates which i express redundantly also in my position so a dump application can just import everything look at the global coordinates of everything and just place it there and then a smart application can say add user just drag this one and i know what relative is so i can now move this one accordingly and recompute the global properties so there we have this nice thing of redundancy and global positions are really global can we achieve the same with size so that size is really just the global size on the global box but scale somehow helps me to recalculate it in a way the other thing it's growing here is like with scale and size as different things is that you end up having thank you for it you end up having a if you want to calculate like overlap or anything like that like hit boxes and that kind of like collision detection that kind of thing of like is there anything at this spot on the canvas you can't just load position and size and run the calculation you have to run position and size and scale and then do the scale and then and then because yeah because it's not actually where it also like screws with like human readability of like i'm looking at this and going it looks like a small one by one square and it's like well no because it has the scale factor i have to like do the math in my head like it's not actually one by one it's a 10 by 10 so i mean we need to distinguish global size and position from local size and position and i will say this is actually like a legitimately good like topic that you're bringing up because um my intuitive sense of of scale is like derived from the fact that i expect all transforms to be like local relative to the parent and that's not the case in oak if with position so that has a bunch of implications for all other transform properties too so scale yeah i mean this ability to nest scales and transforms is crucial to have to have a really zoomable app that's not hindered by double precision of floating point precision but we we want somehow both ready-made global data and a way to compute it better if needed if we wanted to define scale as always like global then if you like are in an app and you scale something by 10 10 does that mean that the app like when it's writing the oak if file it should serialize it should save the beak global position and the global scale of all those nodes to match um so like if you scale the parent nodes then all the child nodes will also have a global scale of 10 10 would that make sense because if position is global maybe scale should be two and then should the relative node extension have its own scale property for local scale that's what i was thinking maybe scale is actually pushed down into the relative node extension and so maybe yeah and then then we don't have this problem of like it's at the global level of like scale only means i can scale these things all together like this right like this is scaled yeah and these these are parent child related to this thing up here and then we don't have this yeah i don't know it that feels right that's a good direction yeah i have a global size i have global position but i give you the formula actually my scale no my size was computed by taking the parent and applying a scale transformation or maybe maybe we have a relative size similar to a relative position we also discussed that with michael last time where we wanted to be able to express positioning within the parent in like i think what erin once demoed where you can say i'm at one one in the parent or i'm at a zero zero or at one one or zero five one yeah and this local positioning is is is very nice just using the parent as a local coordinate system and express your coordinate relative to the parent coordinate system so the parent has a position that has been arrived that is known it has a global position and it has a global size that spans a coordinate system in which i can use a local offset and a local position relative from going from zero to one maybe maybe if the parent has a size that's not square that's a bit weird but besides that i think we are going into a nice direction yeah this this feels good like so yeah we would the the thing to explore i guess here is dropping the scale down to the relation level and what does that what are the implications this occurred it occurred to me while we were thinking about this earlier and i was thinking about testing and examples and all this kind of stuff that this feels like one that would be really helpful to iterate with examples and then say like show what that actually results in of like imagine that you had this you know parent that had these children and you modified the scale property what should happen um well we think you know i don't know this this feels like a very example driven because it's not super intuitive um like you have to hold a lot of things in your head um to whereas some of our other things it's like really straightforward what it means because it doesn't have like sort of cascading impact um because there's other things that we would need to think about too like what happens if this has something inside of it like this thing it has this is this thing is parented by that thing which also has a scale property and this has another scale property and um like yeah there's like some interesting things to think about i know we're we're way past this this bridge and uh you know maybe it's it's uh it's way too late for this but i i do want to just bring up again um if i was designing this format i just wouldn't have the global position at all and i would just have everything be relative to the the parent um and that makes things a lot simpler and to be honest computing the global transform is not like hard like even if you have a dumb app you could have an importer that like computes these things and if if you're like you know your your importer already has available to it some library from multiplying transforms together then you could um which is a trivial operation to implement if needed that could be done in you know like a few dozen lines of code just like get all the node get get its transform get it's get the parent get his transform multiply it then keep going iterating through the parents get their transforms and what's it like it's it's pretty simple i would say so i personally don't see any value of trying to make it easier for dumb apps that can't do this because it's like it's so trivial to me at least yeah i disagree a bit because not all apps are using this zooming really a lot some apps more or less have one canvas where everything you see is everything you get and zooming is more you don't zoom much and for this app world having absolute coordinates is just so much easier to debug stuff and steal stuff i think i think we should have both and if it's so easy to calculate the global positions why not add them in for redundancy too that's actually what i was thinking as well like i think we should i think we should always calculate the absolute for these guys and then also include the local so that applications that support the local can support these like really intelligent transformations like you were to use your word of dumb and intelligent like and perhaps that support that great you know like modify this one parameter and you can scale i love the example you gave of the ui where the the ui was able to be scaled by that one because of the parent child relationships like that's a super cool example but that is a super advanced like layout engine basically and then for the for the sake of export you we just like like you said run the calculation to get those absolute coordinates and then we support a lot of applications that are much simpler and as well as like human readability of like you could actually just look through the file and go like yeah there's something here or you could scan through the file from top to bottom so like calculate a hitbox without doing any calculations you're basically just saying is there anything between this which is kind of interesting but i would even agree to put both in the in the top note standard to have global and local positioning and not have it in relative note extension but have it all in the core standard i think i would love to see i have to render another meeting but i'd love to see like what you mean like maybe right now we have the relative notes extension where we define relative positioning but maybe we should put both position at size ways local and global into one coherent note definition and and beta extension style so it would be where's the example of extension and the thank you sorry um relative note so it would be source is the idea of the source node we would have to move i mean yeah what we even call that like okay so it'd be an optional position optional local position or something like that with an optional source or optional parent or something like that well if if if we if you have it in in main if it's on the if it's on the root level node which is what i understood you to be suggesting yeah maybe we should add it to the parent child thing then instead because as Aaron pointed out having nested transforms without parent child is pointless yeah yeah it's kind of uh at least to me an inherent property of what it means to for be parent and child like the the expectation and game engines is that um that's what it does when you make a node a child of another node it will move when the parent moves but we've i think the thing i like about the way we have it is that we've separated the visual from the semantic so parent child is a semantic uh relation whereas uh sorry uh relative node is actually a visual node so the relative node impacts the impacts how it's displayed whereas the parent child so you can use them independently you can say these things have semantic relationships between each other but don't have any visual like the visual relationship isn't what you would expect from a game engine and the relative node you can say look like this isn't semantic this is just purely like uh this should calculate it off of that i don't want to say anything about them being parents and child children it's just i want a relative i want give me a a relative coordinate space that i can play in i'm just going to put a bunch of nodes in it um and then have them be calculated off of that so i don't know so at least i am with scale into relative node yeah it really really i'm tempted to say we should rename the extension to relative transform because like it should it should in theory be all the transform properties position rotation and scale size is kind of like intrinsic to it so i don't think the size needs to be set because you know if you want to find the global size you can take the the size property and multiply it by the global scale in the same way that you can find the relative size by taking the size property in the relative scale so there's already a global and a local so there's no no point in the size being in here the size is just specified once but the position rotation and scale these are all transform properties that can be either global or local i hear you yeah i think i like it being relative for the sake of being short but we are specifically saying here that it's relative positioning and you're right it's the entire transform stack it's not just position it's we in fact we already have rotation here um so it's like yeah position rotation scale are the three properties for the relative um also i think we have the position wrong right now we have it as an offset which is just added but it should be expressed relative to the coordinate system spent by the parent that would be much more expressive and useful yeah okay some some things to patch up i gotta run guys that it that is correct because if you have a node that's rotated um then like the position of the the child the relative position is going to be relative to the the parent's rotation that's what it should be so if we say the parent spans a coordinate system which is rooted at the so the zero zero of the local coordinate system is the position of the parent and then what is x and y are the size of the parent so x goes from zero to one and one is the right side of the parent and y is from top to bottom and one is the bottom of the parent is is that what's usually done so it's a stretched coordinate system sometimes that is what uh the anchors use because they're referring to like percentages of the parent but yeah i think usually um in like just 2d coordinates it's uh not using the that system is actually just doing like a position in logical pixels uh relative so you know if if if if the parent has a width of 300 and the child is at position of x200 then that's going to be two-thirds of the way within the parent shape so it's it's not 200 times the width of the shape off into the distance okay so it's just drawing the logical pixels and the parent size is like a clipping yeah and if you wanted that that zero to one range then you would um you would use something like the anchors and the reason for that is because usually if you're i think the expectation is that if you resize the parent and you just click on the corner and you drag it then that's not going to like stretch everything inside with it right yeah sometimes it is sometimes it's not so maybe both are needed um i mean if you're like if you're rescaling or you're like changing it to be bigger yeah yeah that's always not clear okay so but let's say we go with what you just explained me so the default is like a clipping semantic and then this anchor is more like the exotic thing so the default positioning is the clipping then what exactly is the size transform affecting so if i have a local position of 200 as in your example and my size is size transform is two does that mean my 200 is now a 400 you mean the scale is of two yeah yeah yeah scale sorry scale then yes uh that that would be the scale multiplies the the child's position in in logical pixels relative the relative position okay yeah yeah that that seems logical okay yeah and the the actual size property of the parent node is not accounted for unless you're using anchors size of the parent is just clipping it only depends on what i finally show in the global canvas yeah and then anchors so if we say we have so we have scale we have rotation and then for position yeah we we still would call it position and then for the anchors if you would want to express the position relative to the parent you would probably say relative position something back like that and then that goes from zero to one and you can either use position or relative position the the typical naming convention is something along the lines of global or local precision I can give you two examples from gay mentions in giddo position is local and then there's a global position for global in unity it's the other way around unity has position which is global and local position which is local and um a lot of people are like mad at unity for doing it that way because in a gay mention context you need the local position all the time so that means you have the word local in there all the time but for oak if uh where the expected use cases more so global is useful it makes sense i guess to have oak if where position is global and then there's a local position for local or should we name the position always global position just to avoid some mistakes we certainly could do that uh it wouldn't it would increase the the size of a file and you know bytes but it can always be compressed that's like the the term global position being present a thousand times and a file is easily compressible so i i would support that for clarity because i think if somebody's coming at this from a different format where local positions are the default then having a position property be the global might be surprising um but i i'm not going to push for that because i don't want to uh curse people with bigger files than necessary i think if yeah if you zip it it doesn't matter and if it's sent over network it is zipped all the time so the size it's more about the typing or the ugliness of the file having longer names but but also i noticed in all our discussions we do had some confusion about local global positions and expectations so yeah we can at least propose on the next meetup to to use the term global position just to be clear i like that and this also means at the same time we could do global rotation and global scale as names for those properties to clarify those why are they global are they local scale and local rotation and then they compose ah if you if you multiply like the true rotation that then results yeah so like if a parent is rotated 10 degrees and the child's rotated 10 degrees and the child's global rotation is 20 degrees yeah of course we obviously need that okay but we don't need global and global scale right because scale can only affect children if a node has a scale of two and a child is a scale of three then this child's global scale will be um six you know um what what local i understand is that but the real global scale of the outermost node is not used for anything i mean global size and global position is is in global rotation is useful to display stuff well if the if the outer most node has a resource itself then it's used for that right because it's used for the the display of like the image to make the image bigger yeah i'm not sure my intuition would be to just make the node is playing the image bigger but by its size so then it is bigger so you know now that i think about it um more closely uh there is there is an interesting point here about the scale and the size scale like usually i think about it as like the purpose of it is to like scale the children with it and if i'm you know making a ui or something in giddo's control nodes then i i usually don't change the scale and i will just change size instead and if i if it's something permanent i'll just resize the children be bigger because it's easier to just not deal with scale if you don't need it so that if it raises a point if we're defining these things global anyway then why do we even need um like scale at all yeah we don't need scale at all because if you if you want to kind of like bake a um a scaled object to an oak if you can just like computes the global size of everything and then write that and then have everything via scale of one and you can you can just essentially get rid of scale you don't need it anymore yeah that this uh there's a ui thing that the ui changes the width and height of the elements you can calculate the local sizes and don't need scale and from the local sizes you can compute the global size as well but if you zoom in a lot you would rely on the local size and local position to display things correctly but if everything is the scale of one so it's on if there's no scale then the concept of global size of local size are the same if you have a child node with a scale of a child node with a size of 100 by 100 it doesn't matter what you do to the parent it's it's it's going to be always that that size you you can't you can't scale the parent because we just said you can't if it's always a scale of one then the the the sizes are that's the that's just the size global or and local both so then to work around limits of doubles we need to honestly man i i don't know about working around the limits of doubles i think if doubles are posing a problem for you then you need to just go implement quadruples like it's a thing there's an IEEE standard for it so in ok if we just don't have any scale factors and you write your position into the position and that's it yeah we just we straight up just don't need scale if everything is going to be global because there's no point the scale is the only use it has is with the parent child relationship as far as i know because if you want to make the node itself bigger you just make the size bigger and if you want to make the children bigger you could always bake that you know the app that's doing the scaling can bake that but it has no separate meaning if you're if you're not going to have the have the local transform be the main transform if we're just doing global everything then just do scale i mean have do no scale and have only size and what about rotation does it still make sense to have global and global rotation seems yeah it it does make sense to to do that yes because like we're talking about replacing you know scale with only the size because that determines how big things are but the rotation is a whole different thing that that needs to be kept so yeah so we have only position which is global only size where this is global then for rotation we distinguish global rotation local rotation then we have the anchor extension maybe to really smartly relatively position things so when you said we have size which is global i i just i think you already know this but i'll just state again that if we don't have scale then there's only one size so it's it's both global and local it's both yeah we only have one size yeah yeah but but each item has a different size maybe yes yeah i mean each each item only has one size defined yeah and then currently we have this relative node extension which uses an offset to place things which is quite redundant to just use a group and say yeah these should also move together so relative node becomes irrelevant and scale needs to go that's sort of yeah the consensus and the rotation needs to be distinguished between global and local so these are the three results they're good results good yeah and they require some spec changes for our candidate recommendation i see yeah this is this this is like one of the unforeseen things that i'm like wait wait wait don't don't push it out yeah we're still we're still talking about this maybe we have everything resolved until May 28th okay i can i can add these changes to the spec and in a VR but it's quite clear how to yeah that was very enlightening for me thank you i'm not sure we are still recording or not i don't see any recording the but before we before we completely close out on that i do want to mention one other thing um so we don't need scale at all if we have size as you know the definitive factor for how big something is but is it possible that somebody will have something in oak if that is not needs to be scaled somehow but it doesn't use size i can't i'm not really sure um like in you know in a 3d model we have like meshes and you the scale will affect the positions of the vertices so the bottle doesn't really have a size to be bounded by it just kind of is these vertices multiplied by the transform um but is is that a thing that is there anything like that in in oak if that would make use of scale in that way i mean it wouldn't make sense for like images and stuff and i guess text you know you could have text can define just a font size as needed right text is his own kind of warmth how you want to have the text being zoomed or not when you zoom around so your mesh example can we find that in a map so for a mesh if we would embed the mesh only using global positions then the import of such a mesh would be a pain because then you would have to recalculate local offsets or somehow do we have you can easily bake the scale um that's like it's actually something that is recommended often because some tools you know don't support scale and so it's common to to bake things occasionally one uh i think it's one use case of one use case of like runtime scaling that i can think of is with like um something like a game that uses FBX files where the games usually use like meters and FBX files are centimeters and so you just import the file as is and then uh you give it a transform to scale everything down by 100 um but that's like that doesn't apply to oak if at all um i think usually you don't even need scale in 3d games okay what about nest that maps then so we use one okra file having only global positions and another look okra file having only global positions and now i import that one into one of these rectangles over here i i need some kind of transform to put that into here right right that's why i say that the only way i can imagine is relative to the the root of the document so if you import it over here or whatever then that's going to take the over here position and just um adds that to the global position of every single node in there essentially but this is never what you want because it would just clip everything out and just if you have two maps being thousand by thousand pixels and import the second one to the first one then you would only see a tiny fraction of it and and and then my then i would just clip uh most of my second canvas so i'm a little bit confused as to to your example here okay let's say these are my two maps yeah and now i want to this one being imported in the tiny rectangle here so that later if i zoom in i see it full oh if i just import it the coordinates would just either overlap completely or being relative and and and then my then i would just clip uh most of my second canvas so whatever you want is to say if i nest the canvas i want it to be zoomed full screen or full rectangle uh where imported so the um the scaling could be done by like um by the importer or whatever or the runtime and a whole file like that could be baked to okif but that is a good point if we have an okif file using another okif file as a resource is that something that we need scale for because maybe not as you pointed out maybe i mean if we have a rectangle that shows a png file we also sort of auto scale it to fit it into that rectangle so what i mean at least that's what's that means in my head we never talked about it uh yeah but what's the coordinate system for the png here but right here here's the thing with that if you have um so if you have say like some node uh has some size and you want to have this nodes resource be another okif file then you need to somehow scale the okif file into this rectangle which means that whether it's implicit or explicit you're saying that the okif file has a size and that's something that we don't do so that's that's tricky so maybe we maybe we do need scale for that case unless we could find another solution we need size for the okif file which is just the bounding box of all content boxes trivially to compute because we have global positions and sizes anyway so we just put all corners to an index and then we get the size and this size implicitly defines the transform that's required to but there are some caveats about the aspect ratio because you don't want your aspect ratio to be messed up so you say you fit the yeah you fit the longest or shortest side to define the transform i mean how how do we display a png if we have a box 100 by 200 by 100 and we say we want to display png 1000 by 1000 that png needs to be rescaled but what is it showing is it showing like the upper half of the png or is it showing the full png and having white boxes on the side we need to define that it's quite crudely absolutely that does need to be a defined job um one excuse us you can define that but with with um opiate um what's it called as this property for it you can call you can say it needs to cover or needs to be contained and then the image behaves differently okay so there's a CSS property that's like that do you know how that's called and usually of the object fit object fit so we should also for background that's the same something okay that's perfect that's exactly what we need so if we add size to the canvas which can also be computed but we can also add it as it's our nature to always add redundancy um and then we have also an object fit when we import any kind of resource actually we need this for any resource then we can just reuse that for importing okay files too and so uh what when it comes to uh defining this my my expectation is that the like the default behavior or whatever would be too stretch uh like a png but it's you know like uh like uh it ends up looking like all squished and stuff in one direction but then for an okay file there's more interesting behaviors that we can do here um including ones that kind of like reveal additional space on the side I guess is what you could put it there the way that this works in game engines with cameras is that you define a certain direction as like the keep direction the keep aspect direction so for example in Incido you have the camera and it has body felt keep height so you define the field view of the camera vertically and then if you make the window bigger you can just see more on the if you make the window wider you just see more on the sides um the the you could also do it the other way though you could have it keep the width and then you you like make the window taller and let's see more up and down direction and vice versa for shrinking you'll just see less if if you shrink it in in those specific directions i have to go by the way yeah okay yeah so the next thanks for being here have a great new weeks see you see you bye-bye so now we've battled all the issues yeah we need something like object fit or keep aspect or mix of the two concepts that's utterly missing from the current spec did you find how to display a resource yeah so yeah if you have like a square square png and you want to display it in a wide box what do you do yeah what's it doesn't say and we just need the property to to state that and we need a reasonable default behavior yeah that makes sense mmm wow i think we resolved a ton of issues today and even found new ones yeah we also resolved yeah no um one thing i i should briefly note is that if you have things that get like squished or stretched or whatever then you do what what that effectively means is that the contents are non-uniformly scaled and non-uniform scales means that the transformation is not what's called conformal anymore and this can mess up a lot of calculations that you want to do so like for example if you're trying to do calculations on a circle and you stretch the circle it's not a circle anymore it's an ellipse and an ellipse can be much harder to calculate things for so but if you if you uniformly scale a circle it's still a circle so some things can get really more tricky if you allow if you if you do non-uniform scale so a lot of engines even though they have you know the x-y and sometimes these scale properties they usually say like oh you should do the uniform scale and only do the non-uniform if you really need it for something because it's like it's going to mess up things so our default should maybe not be the stretch option then it's maybe okay for like an image um and i i don't have a complete list of everything that this messes up but i know it'll completely mess up like a physics engine for example so if you wanted to have stuff in your canvas like move around with physics and bump into things that's going to completely explode if you have non-uniform scales well if we have it as a default setting to add stuff on the side or on the top so just make it as big as possible as it fits into that box and then at white space then for debugging and import purposes you always see what you have and sometimes you see it's too small and then you can resize stuff that seems to be for oak if maybe the most useful default so it doesn't squish so it doesn't mess up math and there is no hidden stuff you always see all your stuff although sometimes a bit small i think that's my my favorite for this reason all right it makes sense um well i think that that wraps it up um yeah so now we have dinner yeah it's it's my supporting here it's almost eight o'clock here p.m so so i'm ready for dinner now yeah wow that was one of the most productive sessions we ever had yeah thank you a lot and even if we keep scale we need to like be very clear about like what it's how to use it what it's for and if we want to replace it by size we have a very good definition of like the keep aspect to stuff um so i guess those are like the two ending notes or whatever yeah all right all right bye so for you have a great day for me i'm done see you next time bye bye you You