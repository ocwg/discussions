There we go. All right, this is Open Canvas Working Group Meeting Number 20. So yeah, we can jump in. Michael, did you have anything? In terms of an agenda, a couple of things. Orion helped me kind of get the spec stuff set up, and then I noticed that we've got some SSL issues. I know what the SSL issues are, and I can fix them, so I'll fix them after this. But in terms of other status updates, Michael, I'd love to yield the floor to you first since you have to go in half an hour if you wanted to talk about anything you've been working on, or show a demo, or whatever now with the agenda.

I was thinking if I could show something only that I can import the Hello World file that I was just looking for, but I have to update on this computer. It's on my laptop, just to have a moment, but that's not that exciting. All demos are exciting to varying degrees. While you're working on getting that set up, Max, Aaron, Orion, do you guys have anything you want to talk about today in particular that I can throw on an agenda?

Yes, there is something I want to talk about. It's with the way position works in Oakiff.

Great, sounds good. I am sure this while we wait for Michael to get set up. I thought we could go over our project in GitHub and do some clearing, but Aaron's topic sounds more relevant. Yeah, we could jump into the position topic and then review the GitHub project. Agreed, there's some stuff to do there.

How about you, Orion, anything to throw in? Are you just hanging out?

Not much top of mind. I think it could be good at this stage to chat a bit about which teams and projects to start some discussion with next. Kind of brings some of those people back into the loop. Because I feel like that's one of the big next important things is adoption.

Agreed. Yeah, that's kind of under. There's a couple, there's a little bit about that on the GitHub project and we can kind of talk about it into there. Rubik of some planning and what can we get done there?

Michael, you ready to go?

Yeah. All right, stop in sharing screen and yours. This is my screen. I hit allow. I don't know if that did anything. You may have to re-invoke it. I don't know. There we go. What I can do, if zoom is not in the way, is import the HelloWorlds.com file. And you just noticed a bug on Windows, on Mac, it works. So I have to dive into that, but this is the... I guess that's supposed to be a German flag. Yeah, exactly. It's a Unicode issue probably. It works on my Mac, not on my Windows laptop, apparently. This is the...

Can you talk about where you got that OCIF HelloWorld file from?

Yeah, I got it from our GitHub, MacSpec, just copy and paste it into a file and imported it. And what my tool does it add some data, but I want to be able to have this as minimal as possible. So I have to do some work there still, because there's some data like this for my own tool, which I don't want to be there when I do an default import. Also things like this, I don't want to be there, as clean as possible. But that's work on my site. That's nothing to do with spec. That also doesn't hurt at all. I mean, that's exactly as the spec was intended. You can put your extra data there. It's just fine.

Yeah, that's true. But in this case, these nodes have no behavior attached. So they run my tool to know already some some core nodes, new types from OCIF, like an arrow and an oval and rectangle that I can just import this without my tool needing to add data. At least I thought that might be a good idea to implement it like that. Once I will, when you are going to attach behavior to this node or change the color or size.

So Aaron and Orion, the Hello World example is literally the first example is if you hit the spec.md and you start scrolling down. It's the first example that shows what OCIF looks like. And so this is the piece of it. It's good to know that that actually successfully imports since we were Max and I were just winging it, writing out that example. Yeah, I'm not sure if I changed anything there. Maybe I did, but it's a week to go already.

Yeah, Jim. Yeah, Michael found actually a few bucks in the initial example, which I then had to fix. So thanks Michael.

Yeah, absolutely. Working code is so helpful. Working code more worth more than this back, for sure. Absolutely. And this means that we could actually have multiple implementations going here in a short time. Because I think my plate is pretty clear in terms of stuff I have to do. So I could probably resume working on the good implementation of this and we could have stuff moving between Michael's app and my app and that would be so cool.

Yeah, that'd be great. That'd be very cool. Oh man, I can't wait. That's exciting.

Well, to that point, unless Michael, you had any the same, I'll ask you the same question that I always ask you, which is like, what was what was challenging, annoying, frustrating about working on this if there's not anything to if you have new stuff, happy to hear it. But yeah, the way the connection works, it's a little bit different than in my own tool. In my own tool, I only have one note that represents the the arrow, I call it connection, but and here you have a visual note and a relation. It's right to do somewhere there. And I think it's important to to handle the oak if format as natively as possible. I think that makes it makes it easier. I currently have my own format that's leading, but I stored the full oak if file in memory as well. There's a stored in the next DB, a storage from the browser. But that way, you don't lose information when you want to export again to oak if then you don't lose any information that that your tool does not support. And if you implement it natively, then of course, you can handle and store everything that's in there.

So are you an export time merging the memory copy with your red first and your own data model to fuse it?

Yeah, I store maybe I can show it a little bit. Now that works. I have the oak if data here. So is it per object a per node or the idea was that you can have multiple flows in a memory? I don't implement that yet fully. There are two flows over here, but this GL flow is a different view of different implementation. Just to show quickly what that does. So this oak if you have their memory is really like the, well, the JSON tree is an object already. Yeah. And this is my own. Let's refresh. This is a storage for my own tool.

So you effectively have each node twice maybe if yeah.

Yeah, I hope one day to have only the oak if format and not everything twice. But this was the quickest way for me to implement it currently. You could also do something in between where you have your own nodes. And for each of them, you attach the imported oak if node. So then when you delete your own node, you can easily also delete the now obsolete oak if node.

Yeah, true. Currently, I want to delete this. I also delete the relation in this oak if part is oak if tree. All right, cool. So you handle the relations deletion there.

Yeah, when I don't have this, if there would be something here that I don't support, they would still need that need this oak if tree to have that.

Yeah, due to our split and error and relation, you are going to have to do some reference resolving anyway. So this solution is actually good.

Yeah, I see. Yeah, I'm curious to how others will solve this, but others is currently how I do it.

Well, thanks for the demo, Michael.

Yeah, I will stop sharing. All right, Aaron, you want to talk about position?

Yeah, let me screen share. Great. Are you kidding me? I need to allow zoom to. Yep. See you in a few minutes. Yeah.

Oh, goodness. So glad that our software is keeping us safe. Yeah, check boxes always keep us safe.

All right, I'm back. I hate how things have to restart to get permission on Oculus. Yeah. All right, can you see my screen?

Yeah. All right.

So I worked on a little bit of implementing this and I ran into a pretty fundamental thing where the spec doesn't is not clear on this and so I can't complete an implementation without this clarified. And the way I see it, there's two ways to do it and there's fundamental problems with each one in the current spec. So even no matter how you interpret it, there's big problems. So it's about this property position. So we have a lot of, there's a lot of things here that is that clarify so many things about this. Like the coordinate system, the pixel, like what part of the node it refers to. So all these points here, they define like how long the vector is, like in which direction it points and where the tip of the vector is, like, you know, what part of the node it refers to. But this does not define where

 the tail of the vector is.

So essentially, is this position a global position or is it a position relative to the parent?

And I'm curious what what answer y'all will have, but like either way, there's like big fundamental issues. So the idea was, I think, a global position.

Right. Okay. So here's the problem with the global position. If you have the parent-child relationship, if you move the parent node, you expect to move like all child nodes with it. So that would mean that an operation that affects the position of one node is going to affect the position variable of lots and lots of nodes. And that's very strange because if you are treating like the OCIF file as a DOM, then you modify like one position variable. You would expect it to only modify that one thing. It did not have cascading effects throughout the rest of the document.

Yes and no. So OCIF is not an in-memory DOM. It's an exchange format. And to make it easy for other tools to import it, it's small like a vector drawing software. So if you open the OCIF file in your software, you move one node or child nodes move as well. But in your software, just probably this parent node is changed. But once you export it, you will calculate the real positions of everything like you do when you render stuff. And then you put the real positions back into the JSON object and export it. That was at least the idea.

Okay, that's a very fair idea like just treat it as like a thing that you you calculate on export and you serialize and stuff. But this breaks down when you try and look at more complex scenarios such as if somebody wants to embed an animation inside the OCIF file, then you have to account for how these values change and affect each other.

We haven't thought about animations at all and probably are not aware of specific issues related to animations. Yeah, we've almost always referred thought of or referred to like the files as sort of static assets. Not that the author of the file can't change the contents of them, but they're not dynamic in the sense that like things are actively moving, at least not under the power of the OCIF spec in any way, shape, or form. Like it would have to be the native, the application that has implemented OCIF is sort of playing forward those animations and that kind of stuff.

And to the original, the conversation we had a few minutes ago between Max and Michael, our assumption is that external implementers of OCIF will have their own internal file format or data representation, data structures that they'll use, they'll be separate from OCIF. And then we'll do perform some sort of merge, render and merge at export time.

But maybe that assumption's wrong. Maybe we should assume that people are actually going to want to use OCIF as a structured data format for their actual data, in which case some of these things become really a lot more relevant like you're pointing out, Aaron.

So what you say there is 100% correct in my case, because when I import an OCIF document into Keto, the final result will be a Keto scene made of Keto nodes in Keto's native format. And the user won't like, no, like they won't have a thing that gets saved version control as the imported thing, but like behind the scenes that's what the code will be doing.

But that's like, it's just it's not enough because if I want to take an animation from like an OCIF file, and we can't figure out how we can define how an animation can move a position without messing up the whole document by ripping parents away from their children or something like that. And I try and import that animation into Keto, then it's a big headache, you know.

Well, maybe we should separate the topics of animation and relative positioning. So maybe we first look at relative positioning, and then move on to animations, because we haven't done anything related to animations, but we have something or relative positioning.

Yeah. So when I bring up animations, I'm giving like an example use case of like where a relative position would be like superior. Well, currently we have relative positions as an extension, where you can say, I have a parent node in OCIF with a global position, I have got a child node in OCIF with a global position, but then you say, no, it's not parent child. It's even that's a built in, but this one has no relative positioning. We have the relative node extension in the spec in the extensions, but open the extensions MD to and I don't know who's sharing, but please share the extensions MD.

I am. I'm sharing. Yeah. And there we have the relative node, and that's the one that can additionally to the two absolute positions say, hey, actually, this child position is not coming off from somewhere, it can be calculated by taking the parent position, applying this relative offset, and then you will get the child position.

If you're a smart software, you can rerun these calculations and store these offsets here. If not, we have calculated in the exporter global positions for you, you can just display it.

So that was the idea here.

Okay. The existence of this like field does like solve the fundamental problem. Like if I were to use this, then I can do everything relative to this. And I can ensure that every, every file has these relative positions in it on export and import, I'll have to calculate it. But I guess my main argument here is that this should be like in the course back, I think, in my opinion, that would be similar to like how GLTF does it. And even good ozone scene format when it saves things, it's always saving like parent relative. And this works better for animations. And with the global position, I would just, it would just end up, I would have to save two position properties in every node in essence.

Yeah, by intention, so that other tools that are too dumped to apply relative positioning can still just look up the position that's there, the global one. But it's only written at export time.

So, okay. So the question then is, what software are we trying to target that calculating a global position will be a complex task? Because I feel like this can be, this could be done like not too, not too hard, you know?

This is the fine line about core and extension that we walked all the time. And we, on many occasions, we made things simpler. So right now, very, very simple JavaScript can just read an oko file, understand barely anything, but just put all the visual notes at their position and you see something correctly, you don't have to do any calculation whatsoever.

Currently, it's a, it's very easy to tinker with a format. And I think that's a good property. I think the other, some specific pieces of software errands since you asked that question that we're looking at targeting in least early on would be things like obsidian's canvas, which is an extremely primitive canvas. And then TL draw and Excalidraw are two of the other sort of targets kind of on the more graphic design-y feeling. It would be things like fig jam, miro, you know, things that have more of a feeling like I'm drawing as opposed to kind of prototypy or sketchy fields that TL draw Excalidraw have, whereas obsidian tends to be more of like an information organization tool, similar to, yeah, it's a couple other canvases in that general category that are mostly about laying out text and like almost like putting note cards on a, on a canvas. So in those cases, they often don't have any parent-child relationships. It's more about, yeah, just their absolute position on the canvas.

Okay. Yeah, I guess it makes sense if it's going to be the common case that a lot of apps using this format will use only just like a flat hierarchy of no parent-child relationships at all. And so there, then all positions are both like the relative position and the global position would be like the same numbers. And this would only, the local, the relative position would only be relevant for small number of cases. And we could be, we could end up being wrong about that, right? And so it's possible that this becomes core later. We did, we worked hard to make extensions between core and like non-core feel very similar. So there's really not a lot of, if you implement both and like kind of play around with them, there's, I don't think there's any real difference, Max, I'm trying to think of it.

No, yeah, assume that the core extensions are available, like, like, implementers of the spec need to provide support for the core extensions, and they don't need to provide support for the, the extensions, like non-core. Is that, is that a correctly stated, Max?

Yeah, exactly. We have this schema section where you have these pairs of short type and long URI fields. That's what you do to establish the local name. And for the built-in core things, we say they are like auto-added. And for the extensions, you need these extra name URI pairs in your file. But that's about it. And we said whenever we have a new version of the spec, we will have at the same time maybe new versions of the core extensions and the extension extensions, they can version on their own. So maybe they change even less or easier to use in the end, we will see. But technically, both are extensions on notes and relations. That's, you have your own property back. And with a type, you'll say which property back you have. In a related concept that we bundle in, that's in core, is the group relation. And a

 lot of whiteboards type software, tail-draw, scaldraw, murals, you know, city. And they provide a concept of like grouping nodes together. But it's not really a parent-child relationship. You're basically just saying when you drag one of these, you should be able to drag all of them. And we represent that using a group relation. And so it's still an absolute position for all of those, for all of those, rather than relative positioning them relative to one another. And that was another argument for us to move relative position out of core, is that we're providing that group relation to capture that very common use case that without providing relative positioning, without using relative positioning to provide it. So, but again, when you actually get to implementing this, we would be very curious to hear your feedback. And if it makes sense to kind of adjust the spec in response to what the actual implementation of it feels like we're happy to do so.

Okay. Well, I don't even need to implement it all the way to just know that what I would like is for, I know this is meant for like infinite canvases, like obsidian and such. To avoid like duplication of effort like throughout the industry, I would like for this to be also a like general purpose UI layout format, at least that's how I'd like to use it in giddo because that's what its control notes are. So like you could take any GUI you make in giddo and like export it as and it basically turns into like a thing that you can import into obsidian and you have like the whole UI with like all the images and stuff and then text and you can like click on it and like move pieces around. So, and that could be like a really useful thing if you wanted to like take something from an app and export it into like, I don't know, Figma or some thing like that. It's like a designer tool and you can just like poke at each individual piece.

Yeah. So, also one thing I should mention is if I'm building an exporter for this, as is with respect, one thing I could do is I could make it so that I mentioned that like the relative position is really important and I would always include it. Actually, I would always include it on everything that's not like a top level node. You know, like if it's if it is a flat hierarchy, I could probably just exclude it all together. But like if there was an animation extension in the future, then we would have to put something in there like you need to include the relative node extension for for animations. If your if your thing is not a top level thing or it's not going to work properly.

Yeah, obviously open. Yeah, I'd love to see how you would define an animation extension for this too at some point. That should be a that should be a really interesting non-core extension for certain applications to be able to provide animations. So, let me show you something called the GLTF asset object model specification. So, when GLTF was first released, they only defined a few things that could be animated like position and rotation and such. But then they later added on this object model. And I think it would just be a smarter move for GLTF to start with the object model as like the only way to refer to properties. So, what this allows you to do is you have these what's called JSON pointers that refer to something in the document like slash cameras slash zero slash something, you know, like you're referring your base of raise hand.

I don't know. Michael had just said to leave. Oh, okay. They're waiting.

Okay. Yeah. So, you refer to these things by JSON pointers. So, you basically just treats the the JSON like a DOM and you dig into every single property that you want to animate and you just refer to it this way. Now, it doesn't mean that you treat it as a DOM like in the final version. What I would do is I would take these JSON pointers to have like a mapping that says, okay, if, you know, this property on this node is being animated, I'm going to map that to this node that I generate in the imported version and this property on that node, and then I animate that instead of the JSON pointer.

Are the double curly braces a placeholder for object?

It's a yeah. So, cameras is like an array. So, it's saying like in cameras, there is an odd there's it's like an array of objects. So, some object in there. So, if you were actually writing a valid file, you write like cameras slash zero slash whatever.

Yeah. And there's there's a lot of these that are that are defined. And also, there has to define like data types like floats float two into phone three, you know. But this is just a standardized way to refer to things. And this the object model itself, they have put in in the core specification as just like a standardized way to refer to things. And then it's up to other extensions to actually use that. But then there is a ratified extension called animation pointer that they have. And lets you animate things by by path. So, we see, yeah, here's an example. So, you have this animation with animations like a built in thing inside of GLTF. It doesn't need to be an oak if, but then you have a pointer to this. So, like, I guess my thing for oak if would be like we can animation extension like this stuff would be inside of some extension somewhere. And then this wouldn't exist because pointer would just be like a part of the regular animation.

So, when when you're saying the difference between the object model way of specifying an object and our current node in oak if is the ability to sort of reference the different children using this passing thing like what I'm trying to I'm trying to like do a diff between object model and our nodes. What's what's missing?

So, object models is just a way to refer to things with with JSON pointers and that is like a very formal way to define this. So, you don't we don't need to restructure anything inside of oak if to make this work. We would just need to say like hey, this is a thing you can do with JSON pointers.

Yeah, because we already have nodes already have IDs. So, you could have a pointer that says slash node slash ID node ID.

Yeah. And then the slash I guess the next slash is like properties that exist on that node.

Yeah. I think the one thing where we are not so nice with respect to JSON pointer is if you have multiple extensions and you want to it's to address the third property bag. But the fact that it is the third is completely irrelevant. You're talking about the property bag that has the type so and so and and this is just not a maybe not a possible JSON pointer query or just not a nice one. So, we would maybe need to introduce some extra syntax some path syntax where you can say I'm taking the node number 17, the property bag for the relative positions and then the property position.

Yeah. So, like this is maybe the missing piece. In GLTF every like item in an array like a node is referred to by an index. So, that's why we have like a zero here. We might want to do something where you do an index as well in OCIF which is like fine for serialization but bad for readability or we could do node slash some ID. And but if we did if we did an ID here that would imply to a reader that the the structure of the document is a dictionary in that place an object in unlike an array like we have right now. So, that's a little bit tricky.

In either case, I do want to make a minor petition. Should we disallow IDs of nodes to from being just straight up numbers like integers so that people don't confuse them with indices?

I wouldn't disallow a lot of things. I would say we will not end up using JSON pointer as is any way because it doesn't fit to the extension model we have. We need some other path syntax.

All right. So, we'll need that to find some more more fancy syntax for this then. But this is a JSON point. There's a good inspiration just allowing us to like yeah flash something or something you know. I can see how you would use that especially in the context of an animation where you're saying basically change this property over this time period you know you know along with easing and all the other things that you can define around yeah it feels it feels very much like CSS animations where you can be like animate this property yeah that's that's cool.

What are some of the other use cases for JSON pointers? It's so obvious in the in the context of animations but where do you where do you find them also to be useful in GLTF?

There's okay so from kronos itself there's only two extensions they have right now they're using it. One is animation pointer. The other one is something called KHR interactivity. Which is this is a ginormous extension because taking a while to load it. So this is essentially an entire scripting system inside of GLTF like a hypercard inside GLTF basically. Yeah Turing completes you know very flexible visual scripting system with no with like script block nodes that like point to each other and like if statements that have like a true and done point to some other thing. So it's it's a it's an entire scripting system.

Yeah there's there's a lot of stuff here to talk about like okay here's some of these like script blocks that exist and here's their inputs and outputs and and so this needs to be able to talk to to GLTF of course that the calculations you make in the scripting system have some effect so that he uses JSON pointer to talk to things to

 yeah it's like set like maybe maybe some event happens and you want to set the position of a node you know.

This would be this would be a very interesting one for Michael to take a look at with his tool which has a lot of interactive elements in it. It might be that he can use it to that there could be an extension to Oak if that represents some of the interactivity in his in his tool. Super interesting.

Yeah so the the thing is though the there's approximately the same like problems we encounter when doing some kind of scripting system versus doing an animation because in a way you kind of make an animation out of a script if you wanted to. They're very very similar challenges so it makes sense that they would be solved in similar ways.

It does yeah I can see that.

Well Aaron good luck. Godot as an export and import for Oak if it's going to be pretty cool. I'm excited about that.

All right so like as a as a conclusion then if if the decision is that we will keep relative position as as an extension and and like encourage the flat hierarchy is the like typical or recommended workflow that that the default thing is geared towards and then if you need like a hierarchy you use that extension then we still need to update this to clarify. We just had a bullet point here say something like this is a position relative to the root of the document and if you need a parent child relationship with the relative position then go look at this extension over here you know.

Yeah that's a great point. Yeah totally agree that would definitely say time if you had known to go look at that and we do explicitly link to the parent child one without linking to the relative position.

Yeah yeah we need to give more pointers also.

Markdown pointers in this case.

Yeah what should we recommend actually it's slightly confusing should you use the group relation to state that things are nested and the application knows if you move somebody here it's a relative position usually or should you use the relative position relative note extension or should you use both we we could give some more guidance on this in the cookbook.

That's true. My expectation as somebody just reading this is that if you want the transform of something they'll always move together that's what the parent child relationship is for. Then a group would be like if you sometimes want to move all the notes together and sometimes one of them separately. The way that I think about it and what we've been talking about Aaron in the last few meetings is this idea of visual visual nodes um nodes represent visual structure on the canvas relations represent um not synthetic what am I trying to say conceptual semantic that was the word max thank you semantic structure and so if we follow that line of reasoning you may want to use the relative node to enforce the visual structure's consistency and also use the group relation to indicate the semantic nature of that kind of group of nodes um so that that same duplication happens in arrow which Michael was showing earlier where there's both a node that represents the visual structure of the arrow on the on the canvas and then there's also a relation an edge relation between those two um objects so that you can and the the thinking hopefully is to be able to extend the support for oakif into the semantic tooling uh some into more semantic tooling that often don't even have a global position they have a auto layout tool or they have more potential layouts well they have no layout maybe it's a very textual wiki-like thing and you can still import it and you still get some hierarchies right because you know what groups are exactly yeah that's why we duplicate the stuff into the visual world and the semantic world yeah using both is probably right i think i think in the cookbook that would be where i would start exploring first so you can see how it looks in the oakifile but i would probably think both um yeah especially but it's also kind of assumes that a canvas supports the relative positioning um right like if you don't really support the relative positioning as a feature in your canvas just don't think about it just use group and global positions and you're good um and then when when importing your tool into gado gado may say oh this is a group i think i'm going to use relative positioning for because it's way easier for me um and so it might add that extension but it also has to on export right out those global positions so that as it goes like round trips back to that piece of software that doesn't support relative positions it can still do the layout appropriately um this does make me think how am i going to represent groups in in gado because like what like isn't go you have a scene graph right it's not yeah not a group there's there's there's not really any groups natively in gado at all um i i could like turn that into a parent child relationship but that doesn't really work well because what if you have um a node that is in multiple groups like it's not it's not a hierarchy no it's not yeah parent child implies that there is a parent whereas a group is basically saying these set of group nodes are related to one another it doesn't actually specify that anyone is a parent or has a child parent relationship to any area well that specific problem is easy to solve i could just create a new node from from dinner and say that is the parent but yeah the the problem of like uh it not being extra hierarchy is this the main issue because you can with a group uh there's nothing in the spec as far as i know this is that a no campaign two groups at once no it can totally be in two groups at once yeah well though that's probably a rare case and we could say usually it should not happen yes i love max's language of should not that's that's that's not precise enough in my opinion like it it's the language of specs right it should and should not yeah but like kronos uh for the GLTF they they have i don't i don't know where this is but they have somewhere written in there in there or read me that they like like extension authors should prefer using must and must not instead of should and should not because it should it's just not clear enough i see i see must and must not i i can get on board with that um let's see um okay this is like a really helpful discussion um oh i i think i was what i was going to say erin about the group relation is if gado doesn't have groups then it you don't have to support that relation in your visualization in your implementation at all you just have to preserve it when you export you can basically ignore it and say like groups don't mean anything in gado so i'm not going to get rid of this thing but i'm also not gonna um i'll just make sure that i reapply it when i export um okay that's hard enough yeah so uh what that means is that i'll probably have to have some piece of data sitting around in the generator scene it's like here are the groups and the data just does nothing in gado at all and only exists to like survive the round trip yep and that's i think this is the biggest onus that we place upon implementers is that yeah but it's it's it's actually hard just let's say we have a group with five members so i import the group and the members and then i delete two of these members and then i re-export the group sure not maybe also delete these two members from the group now yeah but if i don't understand the group then i cannot do that so these are so important if you find a group and these members don't exist silently assume they have been deleted by some other tool and yeah i like what if what if you know i preserve like the the node path of um well a no path in gado is just like name slash name slash name that refers to like a node um and what if uh i save all the no pass of the the nodes that are in this group and then like the user renames one and then they export and then i lose the reference to it because you know yeah no three small they have tons of these three edge cases there's uh i feel like i can do my i could do some effort to preserve groups but like at at some level the user has to like know oh groups are not like supported in this app so like it is really sketchy if you're going to get the right thing on export if you're heavily modifying the data yeah i think that's the reality yeah that's how it is yeah exactly we're bridging things that were never built to be bridged but at least we can provide a like narrow bridge between the two that uh you think in between them i i also want to mention that like this concept of like preserving data that like is not in your app is a thing that i think is generally like a good idea but there's not really much precedent in the industry as far as i see because every GLTF tool it just like discards any data it doesn't know about it's it's like you throw a GLTF with a custom extension uh into giddo round-trip it data's gone into blender round-trip it data's gone into GLTF transformed data's gone like because it just imports it what it can and that it it forgets the rest of the blocks everything else on the floor yeah and that that is is kind of unfortunate and um even with a simple tool like GLTF transform i've i've asked the author of GLTF transformed to just add a setting to like copy over the extensions as is if they're not recognized and they said no i said okay how about like you let me whitelist an extension and just copy that extension's data over and he said no and i'm like okay why and is it because uh what if an extension refers to like uh an image and my tool modifies the list of images and then that the reference isn't invalid anymore and and my response is okay well what if my extension doesn't reference an image can i copy that extensions data anyway and he said no so that there i don't i don't know why but people

 in the GLTF world are really really picky about parsing everything into like some known data structure and then like sending it back out i get it well at the last resort you could take an okith file imported into Godot edited exported back into uh Godot storage from it and now you are imported tries to reconcile what you put in what came back out do we still have some loads and try to put it back into okith of course so that the okith export and the incoming to preserve more stuff that's a good point so maybe there could be some option for like exporting with a with an existing file as a base where it like does the export and then like tries to overlay it onto the existing file and merge it somehow yeah it's a merge it's a merge operation where it's like update instead of delete kind of thing um of like try to update the two it's going to be an i think it'd be a really useful utility to write generally for the ecosystem and then hopefully authors could use that that that tool to provide to try to provide that sort of naive merge um yeah generic merge operation exactly yep it's which has like a rule file to know which precedents to take or yeah yeah you could prioritize you could say like this is the old file this is the new file you could say these two files are unrelated but i just want to merge them it's like a copy operation where i want to take both so to speak um yeah there's some interesting stuff that could be done there so speaking of stuff that could be done we have a few minutes left uh i'm going to share my screen and bring up the github projects uh and i'm just going to capture that idea that we were just talking about um merge a to generic merge to OCIF update okay um i'll make it to the draft for now um cool so if you look at the board we shipped zero dot three um in the last couple weeks i started serving the spec URLs at spec canvas protocol dot org i have some fixes to do with the ssl um that i'll get to um yeah let's see i guess i'll walk the board backwards we talked about normalizing the file names max um i think this is probably i guess we can do that now um but when i was going through the um the spec serving uh geese i was trying to use wildcards to be able to to reference these different files and it turns out that they're not named appropriately um so they could name them correct like rename things so that they're correct yeah yeah the the zero two one was the annoying one um we didn't we worked on a zero two pr and then on that pr without merging back to main kind of took zero two to zero two one so there's uh there's some get history on a pull request somewhere about what was in zero two before we went to zero two one but i don't i don't know that's that necessary it's fine if we will never find it we just set zero two one and why not i mean who cares i don't think it really matters to recover it i just um it's just it'll be a funny thing one day like why doesn't this building have a 17th floor why does it go from zero dot one zero two one like i mean look at the adjacent schema versions they are completely weird time points yeah these candidates they're due like they went to like from draft three draft four to like draft 2020 something you know uh gotcha all right so this one now is the one for fixing the SSL problems um so yeah Orion your specific question was what tool what teams and tools should we engage for adoption um my thinking uh in terms of the last time we talked about this i was saying that one of the best ones to target probably early on would be obsidian canvas for a lot of reasons um obsidian canvas has is really minimal feature set um here and then also people in the obsidian canvas ecosystem are used to the idea of like adjacent style format of a file that they can pass around and load into an application and that kind of stuff like i feel like um ideologically the obsidian community is extremely well aligned with canvas protocol um and so building that format that converter to a converter could be great um and then um yeah that would be my my guess and then from from there i was thinking like tl draw makes an an interesting target because there is a there's an extensive excaladraw plugin for obsidian um but there's not i think the tl draw one is either no longer working or kind of out of date or behind or whatever so there are people who like to use tl draw and like to use obsidian and if we just had obsidian to oakiff and tl draw to oakiff people like people like myself who are uh using tl draw all the time could like export this into obsidian and then be able to see it using obsidian canvases tool so that would be so cool yeah yeah i i think that's that's a good plan as the first two targets i think on the obsidian side they're targeting the the community and the people making extensions um not not trying to go over something first party but to support like an importer the will take oakiff and chugging into a uh obsidian canvas yeah even even if that version of it is it lossy which it which it would be without true first past first party sport right right and that that kind of comes back to the idea that we were just talking about of having a generic merge operation if you had a generic merge operation when you're doing the export um you could attempt to recover what's in the oakiff file as it was originally even if it got dropped on the ground by obsidian when it loaded it into obsidian canvas i just don't like i'm very curious how well that would work um max what are some other stuff that's on your uh yeah two two small things one is about the z ordering uh we discussed this specific point that we said if we have a rectal oval or whatever and then and it's also showing a resource then the rect and the line of the rect is on top and the images behind so you can use it as a frame but another common case is you have a rectangle it has a border and your resource is text and you would like the color of the rectangle be in the background so if we could say the rectangle line is in the foreground z index vice the resource it comes in the middle and the color of the rectangle is the background color then we would address the most common case i think i've wrote this in the spec already but we should uh agree on that it sounds like that is in respect did you and you can make that up on this um set order here we should have it z-order the stroke yeah the field color should be rendered behind the resource so that's yeah but i made that up on the spot uh without discussing what do you i think that makes sense okay that's fine then then we resource our uh issue here yeah yeah good call anybody else have any questions about that Orion or Aaron before we that thumbs up it we can also change these errand to must and that makes it feel better i i agree with that i i think must and must not is as much better language wherever we can use that i i think uh me personally i'm i'm most concerned about like uh the specifics about like transforms and positions because i want to make sure that the the way that every everything's laid out and how they are relative to each other um you know is is correct it'll be really weird if like a UI just like exploded in the user's face but if there's some minor rendering problem uh we're like some thing is not rendered right that to me that's a lot more minor than you know everything going off every which way um so i i'm more comfortable with should in this case but like i i in general must is is good so like if you go to switch it to must then sure we can um another question that came up in my head is what do we recommend on using the group relation which is in core or the parent child relation which is in extensions because they're similar the group says i contain these and the parent child says i'm contained in that one so the group is more concise often but when to use what should you use both if you let's say you inherit from a child uh it's a bit redundant that not clear what guidance we should i should give no but maybe it takes longer to discuss discuss that yeah i'll add it as like a a task and yeah um something we i can do next before the next meeting in two weeks is kind of go through this list and see if anything warrants discussion um yeah to do to do cool yeah all right um we are a few minutes over our one o'clock meeting time ending anything i'm anything needs to go into the task item i think this board is available to Aaron and Orion you should be able to see this it's public so feel free to toss tasks in here or move tasks forward as you're working on if you if you wish but all right as like two closing thoughts i will mention um as somebody who's biased in terms of uh geotaphic game engines i will always vote for the relative positioning being the the only way to do things or whatever um but uh the way that this works as an extension and works fine uh probably um so i think i'll i'll work on implementing this i don't see any conceptual hurdles now um other closing thought i want to mention is the stuff about like json pointers or some other way to refer to properties that is whether that is in the core or not we should really think about how that's going to work before version one of of oak if because it would be weird if like when we did come up with a way to refer to properties we had it be like really janky because it doesn't because uh the format you know is hard to refer to things in you know mm-hmm yeah i put the first idea in the chat here and yeah but but this is certainly a discussion i think we should tackle in time and think about a pointer way to address individual properties in each node for scripting in animations that

's clearly needed if we should standardize it otherwise yeah that won't work together yeah we could uh that sounds like a really good use case for a discussion item uh and kind of i'm curious to see if other people have different points of view on it as well cool all right folks see y'all in two weeks if not before.